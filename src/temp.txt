=
    //NAV
    /**
     * This method takes the node passed in as a parameter and centers it in the view. It is recursive
     * so if the node is nested in collections, its parents will be centered too.
     */
    public CenterNode(node: NodeStore) {

        let scale: number;
        let XView: number;
        let YView: number;

        //base case: parent is main
        if(node.Parent == RootStore.Instance.MainNodeCollection){
            scale = RootStore.Instance.MainNodeCollection.Scale;
            XView =(-node.X * scale) + (window.innerWidth / 2) - (node.Width * scale / 2 ) ;
            YView = (-node.Y * scale) +(window.innerHeight / 2) - (node.Height * scale / 2) ;
            RootStore.Instance.MainNodeCollection.SetViewportXY(XView, YView);
        }
        //parent is not main, parent is centered and calls itself
        else{
            scale = node.Parent.Scale;
            XView = (-node.X * scale) + (node.Parent.Width / 2) - (node.Width * scale / 2 );
            YView = (-node.Y * scale) +(node.Parent.Height / 2) - (node.Height * scale / 2);
            node.Parent.SetViewportXY(XView, YView);

            return this.CenterNode(node.Parent);
        }

    }

    @observable
    public SetViewportXY(x: number, y: number) {
        this.ViewportX = x;
        this.ViewportY = y;
    }


    //NAV
    /**
     * This method sets the position of the new node to the center of the window/collection
     * it is in.
     */
    private SetPosition(node: NodeStore){
        let windowWidth: number;
        let windowHeight: number;
        let cornerX: number;
        let cornerY: number;

        //size of parent is size of window if parent is root
        if (node.Parent === RootStore.Instance.MainNodeCollection) {
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
        }
        //size of parent is size of collection node if not main
        else {
            windowWidth = node.Parent.Width;
            windowHeight = node.Parent.Height;
        }

        //corner of the parent's viewport (top left)
        cornerX = node.Parent.ViewportX;
        cornerY = node.Parent.ViewportY;

        //calculates node's position
        let x = (windowWidth / 2 - cornerX) / node.Parent.Scale - node.Width / 2;
        let y = (windowHeight / 2 - cornerY) / node.Parent.Scale - node.Height / 2;

        //sets node's position
        node.X = x;
        node.Y = y;
    }

    /**
     * This method finds the collection that has a name corresponding with the string
     * passed in as a parameter.
     */
    private findCollection(name: string): NodeCollectionStore {

        for (let cur of RootStore.Instance.Collections) {
            if (name === cur.Title) {
                return cur;
            }
        }

        return null;
    }
 
    //NAV
    /**
     * This method resets all of the Z indices of the nodes to 0 so that one of them could be brought forward.
     */
    @observable
    private resetZIndices() {
        for (let node of RootStore.Instance.Nodes) {
            node.zIndex = 0;
        }
    }

    //NAV
    /**
     * This method brings the node passed in as a parameter to the front by resetting all of the
     * z indices to 0, and then setting the one passed in to have a z index of 1
     */
    @observable
    public bringForward(node: NodeStore) {
        this.resetZIndices();
        node.zIndex = 1;
    }