/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.19.2.0 (NJsonSchema v9.10.73.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming



export enum AggregateFunction {
    None = "None",
    Sum = "Sum",
    SumE = "SumE",
    Count = "Count",
    Min = "Min",
    Max = "Max",
    Avg = "Avg",
}

export abstract class AggregateParameters implements IAggregateParameters {

    protected _discriminator: string;

    public Equals(other: Object): boolean {
        return this == other;
    }
    constructor(data?: IAggregateParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AggregateParameters";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): AggregateParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "AverageAggregateParameters") {
            let result = new AverageAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SingleDimensionAggregateParameters") {
            throw new Error("The abstract class 'SingleDimensionAggregateParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "CountAggregateParameters") {
            let result = new CountAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "KDEAggregateParameters") {
            let result = new KDEAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MarginAggregateParameters") {
            let result = new MarginAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MaxAggregateParameters") {
            let result = new MaxAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MinAggregateParameters") {
            let result = new MinAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SumAggregateParameters") {
            let result = new SumAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SumEstimationAggregateParameters") {
            let result = new SumEstimationAggregateParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AggregateParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        return data;
    }
}

export interface IAggregateParameters {
}

export abstract class SingleDimensionAggregateParameters extends AggregateParameters implements ISingleDimensionAggregateParameters {
    attributeParameters?: AttributeParameters | undefined;
    distinctAttributeParameters?: AttributeParameters | undefined;

    constructor(data?: ISingleDimensionAggregateParameters) {
        super(data);
        this._discriminator = "SingleDimensionAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.attributeParameters = data["AttributeParameters"] ? AttributeParameters.fromJS(data["AttributeParameters"]) : <any>undefined;
            this.distinctAttributeParameters = data["DistinctAttributeParameters"] ? AttributeParameters.fromJS(data["DistinctAttributeParameters"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleDimensionAggregateParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "AverageAggregateParameters") {
            let result = new AverageAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CountAggregateParameters") {
            let result = new CountAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "KDEAggregateParameters") {
            let result = new KDEAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MarginAggregateParameters") {
            let result = new MarginAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MaxAggregateParameters") {
            let result = new MaxAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MinAggregateParameters") {
            let result = new MinAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SumAggregateParameters") {
            let result = new SumAggregateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SumEstimationAggregateParameters") {
            let result = new SumEstimationAggregateParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'SingleDimensionAggregateParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttributeParameters"] = this.attributeParameters ? this.attributeParameters.toJSON() : <any>undefined;
        data["DistinctAttributeParameters"] = this.distinctAttributeParameters ? this.distinctAttributeParameters.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISingleDimensionAggregateParameters extends IAggregateParameters {
    attributeParameters?: AttributeParameters | undefined;
    distinctAttributeParameters?: AttributeParameters | undefined;
}

export class AverageAggregateParameters extends SingleDimensionAggregateParameters implements IAverageAggregateParameters {

    constructor(data?: IAverageAggregateParameters) {
        super(data);
        this._discriminator = "AverageAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): AverageAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AverageAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAverageAggregateParameters extends ISingleDimensionAggregateParameters {
}

export abstract class AttributeParameters implements IAttributeParameters {
    visualizationHints?: VisualizationHint[] | undefined;
    rawName?: string | undefined;
    public Equals(other: Object): boolean {
        return this == other;
    }

    protected _discriminator: string;

    constructor(data?: IAttributeParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AttributeParameters";
    }

    init(data?: any) {
        if (data) {
            if (data["VisualizationHints"] && data["VisualizationHints"].constructor === Array) {
                this.visualizationHints = [];
                for (let item of data["VisualizationHints"])
                    this.visualizationHints.push(item);
            }
            this.rawName = data["RawName"];
        }
    }

    static fromJS(data: any): AttributeParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "AttributeBackendParameters") {
            let result = new AttributeBackendParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AttributeCaclculatedParameters") {
            throw new Error("The abstract class 'AttributeCaclculatedParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "AttributeCodeParameters") {
            let result = new AttributeCodeParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AttributeColumnParameters") {
            let result = new AttributeColumnParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AttributeParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        if (this.visualizationHints && this.visualizationHints.constructor === Array) {
            data["VisualizationHints"] = [];
            for (let item of this.visualizationHints)
                data["VisualizationHints"].push(item);
        }
        data["RawName"] = this.rawName;
        return data;
    }
}

export interface IAttributeParameters {
    visualizationHints?: VisualizationHint[] | undefined;
    rawName?: string | undefined;
}

export enum VisualizationHint {
    TreatAsEnumeration = "TreatAsEnumeration",
    DefaultFlipAxis = "DefaultFlipAxis",
    Image = "Image",
}

export abstract class AttributeCaclculatedParameters extends AttributeParameters implements IAttributeCaclculatedParameters {

    constructor(data?: IAttributeCaclculatedParameters) {
        super(data);
        this._discriminator = "AttributeCaclculatedParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): AttributeCaclculatedParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "AttributeBackendParameters") {
            let result = new AttributeBackendParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AttributeCodeParameters") {
            let result = new AttributeCodeParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AttributeCaclculatedParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAttributeCaclculatedParameters extends IAttributeParameters {
}

export class AttributeBackendParameters extends AttributeCaclculatedParameters implements IAttributeBackendParameters {
    id?: string | undefined;

    constructor(data?: IAttributeBackendParameters) {
        super(data);
        this._discriminator = "AttributeBackendParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): AttributeBackendParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeBackendParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IAttributeBackendParameters extends IAttributeCaclculatedParameters {
    id?: string | undefined;
}

export class AttributeCodeParameters extends AttributeCaclculatedParameters implements IAttributeCodeParameters {
    code?: string | undefined;

    constructor(data?: IAttributeCodeParameters) {
        super(data);
        this._discriminator = "AttributeCodeParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.code = data["Code"];
        }
    }

    static fromJS(data: any): AttributeCodeParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeCodeParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        super.toJSON(data);
        return data;
    }
}

export interface IAttributeCodeParameters extends IAttributeCaclculatedParameters {
    code?: string | undefined;
}

export class AttributeColumnParameters extends AttributeParameters implements IAttributeColumnParameters {

    constructor(data?: IAttributeColumnParameters) {
        super(data);
        this._discriminator = "AttributeColumnParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): AttributeColumnParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeColumnParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAttributeColumnParameters extends IAttributeParameters {
}

export class CountAggregateParameters extends SingleDimensionAggregateParameters implements ICountAggregateParameters {

    constructor(data?: ICountAggregateParameters) {
        super(data);
        this._discriminator = "CountAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CountAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new CountAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICountAggregateParameters extends ISingleDimensionAggregateParameters {
}

export class KDEAggregateParameters extends SingleDimensionAggregateParameters implements IKDEAggregateParameters {
    nrOfSamples?: number | undefined;

    constructor(data?: IKDEAggregateParameters) {
        super(data);
        this._discriminator = "KDEAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.nrOfSamples = data["NrOfSamples"];
        }
    }

    static fromJS(data: any): KDEAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new KDEAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NrOfSamples"] = this.nrOfSamples;
        super.toJSON(data);
        return data;
    }
}

export interface IKDEAggregateParameters extends ISingleDimensionAggregateParameters {
    nrOfSamples?: number | undefined;
}

export class MarginAggregateParameters extends SingleDimensionAggregateParameters implements IMarginAggregateParameters {
    aggregateFunction?: AggregateFunction | undefined;

    constructor(data?: IMarginAggregateParameters) {
        super(data);
        this._discriminator = "MarginAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.aggregateFunction = data["AggregateFunction"];
        }
    }

    static fromJS(data: any): MarginAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new MarginAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AggregateFunction"] = this.aggregateFunction;
        super.toJSON(data);
        return data;
    }
}

export interface IMarginAggregateParameters extends ISingleDimensionAggregateParameters {
    aggregateFunction?: AggregateFunction | undefined;
}

export class MaxAggregateParameters extends SingleDimensionAggregateParameters implements IMaxAggregateParameters {

    constructor(data?: IMaxAggregateParameters) {
        super(data);
        this._discriminator = "MaxAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): MaxAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new MaxAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMaxAggregateParameters extends ISingleDimensionAggregateParameters {
}

export class MinAggregateParameters extends SingleDimensionAggregateParameters implements IMinAggregateParameters {

    constructor(data?: IMinAggregateParameters) {
        super(data);
        this._discriminator = "MinAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): MinAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new MinAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IMinAggregateParameters extends ISingleDimensionAggregateParameters {
}

export class SumAggregateParameters extends SingleDimensionAggregateParameters implements ISumAggregateParameters {

    constructor(data?: ISumAggregateParameters) {
        super(data);
        this._discriminator = "SumAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SumAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SumAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISumAggregateParameters extends ISingleDimensionAggregateParameters {
}

export class SumEstimationAggregateParameters extends SingleDimensionAggregateParameters implements ISumEstimationAggregateParameters {

    constructor(data?: ISumEstimationAggregateParameters) {
        super(data);
        this._discriminator = "SumEstimationAggregateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SumEstimationAggregateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SumEstimationAggregateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISumEstimationAggregateParameters extends ISingleDimensionAggregateParameters {
}

export enum OrderingFunction {
    None = 0,
    SortUp = 1,
    SortDown = 2,
}

export abstract class BinningParameters implements IBinningParameters {
    attributeParameters?: AttributeParameters | undefined;

    protected _discriminator: string;

    constructor(data?: IBinningParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BinningParameters";
    }

    init(data?: any) {
        if (data) {
            this.attributeParameters = data["AttributeParameters"] ? AttributeParameters.fromJS(data["AttributeParameters"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BinningParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "EquiWidthBinningParameters") {
            let result = new EquiWidthBinningParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SingleBinBinningParameters") {
            let result = new SingleBinBinningParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BinningParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["AttributeParameters"] = this.attributeParameters ? this.attributeParameters.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBinningParameters {
    attributeParameters?: AttributeParameters | undefined;
}

export class EquiWidthBinningParameters extends BinningParameters implements IEquiWidthBinningParameters {
    minValue?: number | undefined;
    maxValue?: number | undefined;
    requestedNrOfBins?: number | undefined;
    referenceValue?: number | undefined;
    step?: number | undefined;

    constructor(data?: IEquiWidthBinningParameters) {
        super(data);
        this._discriminator = "EquiWidthBinningParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.minValue = data["MinValue"];
            this.maxValue = data["MaxValue"];
            this.requestedNrOfBins = data["RequestedNrOfBins"];
            this.referenceValue = data["ReferenceValue"];
            this.step = data["Step"];
        }
    }

    static fromJS(data: any): EquiWidthBinningParameters {
        data = typeof data === 'object' ? data : {};
        let result = new EquiWidthBinningParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MinValue"] = this.minValue;
        data["MaxValue"] = this.maxValue;
        data["RequestedNrOfBins"] = this.requestedNrOfBins;
        data["ReferenceValue"] = this.referenceValue;
        data["Step"] = this.step;
        super.toJSON(data);
        return data;
    }
}

export interface IEquiWidthBinningParameters extends IBinningParameters {
    minValue?: number | undefined;
    maxValue?: number | undefined;
    requestedNrOfBins?: number | undefined;
    referenceValue?: number | undefined;
    step?: number | undefined;
}

export class SingleBinBinningParameters extends BinningParameters implements ISingleBinBinningParameters {

    constructor(data?: ISingleBinBinningParameters) {
        super(data);
        this._discriminator = "SingleBinBinningParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): SingleBinBinningParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SingleBinBinningParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISingleBinBinningParameters extends IBinningParameters {
}

export class Attribute implements IAttribute {
    displayName?: string | undefined;
    rawName?: string | undefined;
    description?: string | undefined;
    dataType?: DataType | undefined;
    visualizationHints?: VisualizationHint[] | undefined;
    isTarget?: boolean | undefined;

    constructor(data?: IAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["DisplayName"];
            this.rawName = data["RawName"];
            this.description = data["Description"];
            this.dataType = data["DataType"];
            if (data["VisualizationHints"] && data["VisualizationHints"].constructor === Array) {
                this.visualizationHints = [];
                for (let item of data["VisualizationHints"])
                    this.visualizationHints.push(item);
            }
            this.isTarget = data["IsTarget"];
        }
    }

    static fromJS(data: any): Attribute {
        data = typeof data === 'object' ? data : {};
        let result = new Attribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DisplayName"] = this.displayName;
        data["RawName"] = this.rawName;
        data["Description"] = this.description;
        data["DataType"] = this.dataType;
        if (this.visualizationHints && this.visualizationHints.constructor === Array) {
            data["VisualizationHints"] = [];
            for (let item of this.visualizationHints)
                data["VisualizationHints"].push(item);
        }
        data["IsTarget"] = this.isTarget;
        return data;
    }
}

export interface IAttribute {
    displayName?: string | undefined;
    rawName?: string | undefined;
    description?: string | undefined;
    dataType?: DataType | undefined;
    visualizationHints?: VisualizationHint[] | undefined;
    isTarget?: boolean | undefined;
}

export enum DataType {
    Int = "Int",
    String = "String",
    Float = "Float",
    Double = "Double",
    DateTime = "DateTime",
    Object = "Object",
    Undefined = "Undefined",
}

export class AttributeGroup implements IAttributeGroup {
    name?: string | undefined;
    attributeGroups?: AttributeGroup[] | undefined;
    attributes?: Attribute[] | undefined;

    constructor(data?: IAttributeGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            if (data["AttributeGroups"] && data["AttributeGroups"].constructor === Array) {
                this.attributeGroups = [];
                for (let item of data["AttributeGroups"])
                    this.attributeGroups.push(AttributeGroup.fromJS(item));
            }
            if (data["Attributes"] && data["Attributes"].constructor === Array) {
                this.attributes = [];
                for (let item of data["Attributes"])
                    this.attributes.push(Attribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttributeGroup {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (this.attributeGroups && this.attributeGroups.constructor === Array) {
            data["AttributeGroups"] = [];
            for (let item of this.attributeGroups)
                data["AttributeGroups"].push(item.toJSON());
        }
        if (this.attributes && this.attributes.constructor === Array) {
            data["Attributes"] = [];
            for (let item of this.attributes)
                data["Attributes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAttributeGroup {
    name?: string | undefined;
    attributeGroups?: AttributeGroup[] | undefined;
    attributes?: Attribute[] | undefined;
}

export class Catalog implements ICatalog {
    supportedOperations?: string[] | undefined;
    schemas?: Schema[] | undefined;

    constructor(data?: ICatalog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["SupportedOperations"] && data["SupportedOperations"].constructor === Array) {
                this.supportedOperations = [];
                for (let item of data["SupportedOperations"])
                    this.supportedOperations.push(item);
            }
            if (data["Schemas"] && data["Schemas"].constructor === Array) {
                this.schemas = [];
                for (let item of data["Schemas"])
                    this.schemas.push(Schema.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Catalog {
        data = typeof data === 'object' ? data : {};
        let result = new Catalog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.supportedOperations && this.supportedOperations.constructor === Array) {
            data["SupportedOperations"] = [];
            for (let item of this.supportedOperations)
                data["SupportedOperations"].push(item);
        }
        if (this.schemas && this.schemas.constructor === Array) {
            data["Schemas"] = [];
            for (let item of this.schemas)
                data["Schemas"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICatalog {
    supportedOperations?: string[] | undefined;
    schemas?: Schema[] | undefined;
}

export class Schema implements ISchema {
    rootAttributeGroup?: AttributeGroup | undefined;
    displayName?: string | undefined;
    augmentedFrom?: string | undefined;
    rawName?: string | undefined;
    problemDescription?: string | undefined;
    darpaProblemDoc?: DarpaProblemDoc | undefined;
    distinctAttributeParameters?: AttributeParameters | undefined;
    darpaDatasetDoc?: DarpaDatasetDoc | undefined;
    darpaDatasetLocation?: string | undefined;
    isMultiResourceData?: boolean | undefined;
    problemFinderRows?: ProblemFinderRows[] | undefined;
    correlationRows?: ProblemFinderRows[] | undefined;

    constructor(data?: ISchema) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rootAttributeGroup = data["RootAttributeGroup"] ? AttributeGroup.fromJS(data["RootAttributeGroup"]) : <any>undefined;
            this.displayName = data["DisplayName"];
            this.augmentedFrom = data["AugmentedFrom"];
            this.rawName = data["RawName"];
            this.problemDescription = data["ProblemDescription"];
            this.darpaProblemDoc = data["DarpaProblemDoc"] ? DarpaProblemDoc.fromJS(data["DarpaProblemDoc"]) : <any>undefined;
            this.distinctAttributeParameters = data["DistinctAttributeParameters"] ? AttributeParameters.fromJS(data["DistinctAttributeParameters"]) : <any>undefined;
            this.darpaDatasetDoc = data["DarpaDatasetDoc"] ? DarpaDatasetDoc.fromJS(data["DarpaDatasetDoc"]) : <any>undefined;
            this.darpaDatasetLocation = data["DarpaDatasetLocation"];
            this.isMultiResourceData = data["IsMultiResourceData"];
            if (data["ProblemFinderRows"] && data["ProblemFinderRows"].constructor === Array) {
                this.problemFinderRows = [];
                for (let item of data["ProblemFinderRows"])
                    this.problemFinderRows.push(ProblemFinderRows.fromJS(item));
            }
            if (data["CorrelationRows"] && data["CorrelationRows"].constructor === Array) {
                this.correlationRows = [];
                for (let item of data["CorrelationRows"])
                    this.correlationRows.push(ProblemFinderRows.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Schema {
        data = typeof data === 'object' ? data : {};
        let result = new Schema();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RootAttributeGroup"] = this.rootAttributeGroup ? this.rootAttributeGroup.toJSON() : <any>undefined;
        data["DisplayName"] = this.displayName;
        data["AugmentedFrom"] = this.augmentedFrom;
        data["RawName"] = this.rawName;
        data["ProblemDescription"] = this.problemDescription;
        data["DarpaProblemDoc"] = this.darpaProblemDoc ? this.darpaProblemDoc.toJSON() : <any>undefined;
        data["DistinctAttributeParameters"] = this.distinctAttributeParameters ? this.distinctAttributeParameters.toJSON() : <any>undefined;
        data["DarpaDatasetDoc"] = this.darpaDatasetDoc ? this.darpaDatasetDoc.toJSON() : <any>undefined;
        data["DarpaDatasetLocation"] = this.darpaDatasetLocation;
        data["IsMultiResourceData"] = this.isMultiResourceData;
        if (this.problemFinderRows && this.problemFinderRows.constructor === Array) {
            data["ProblemFinderRows"] = [];
            for (let item of this.problemFinderRows)
                data["ProblemFinderRows"].push(item.toJSON());
        }
        if (this.correlationRows && this.correlationRows.constructor === Array) {
            data["CorrelationRows"] = [];
            for (let item of this.correlationRows)
                data["CorrelationRows"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISchema {
    rootAttributeGroup?: AttributeGroup | undefined;
    displayName?: string | undefined;
    augmentedFrom?: string | undefined;
    rawName?: string | undefined;
    problemDescription?: string | undefined;
    darpaProblemDoc?: DarpaProblemDoc | undefined;
    distinctAttributeParameters?: AttributeParameters | undefined;
    darpaDatasetDoc?: DarpaDatasetDoc | undefined;
    darpaDatasetLocation?: string | undefined;
    isMultiResourceData?: boolean | undefined;
    problemFinderRows?: ProblemFinderRows[] | undefined;
    correlationRows?: ProblemFinderRows[] | undefined;
}

export class DarpaProblemDoc implements IDarpaProblemDoc {
    about?: ProblemAbout | undefined;
    inputs?: ProblemInputs | undefined;

    constructor(data?: IDarpaProblemDoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.about = data["about"] ? ProblemAbout.fromJS(data["about"]) : <any>undefined;
            this.inputs = data["inputs"] ? ProblemInputs.fromJS(data["inputs"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DarpaProblemDoc {
        data = typeof data === 'object' ? data : {};
        let result = new DarpaProblemDoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["about"] = this.about ? this.about.toJSON() : <any>undefined;
        data["inputs"] = this.inputs ? this.inputs.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDarpaProblemDoc {
    about?: ProblemAbout | undefined;
    inputs?: ProblemInputs | undefined;
}

export class ProblemAbout implements IProblemAbout {
    problemID?: string | undefined;
    problemName?: string | undefined;
    problemDescription?: string | undefined;
    taskType?: string | undefined;
    taskSubType?: string | undefined;
    problemSchemaVersion?: string | undefined;
    problemVersion?: string | undefined;

    constructor(data?: IProblemAbout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.problemID = data["problemID"];
            this.problemName = data["problemName"];
            this.problemDescription = data["problemDescription"];
            this.taskType = data["taskType"];
            this.taskSubType = data["taskSubType"];
            this.problemSchemaVersion = data["problemSchemaVersion"];
            this.problemVersion = data["problemVersion"];
        }
    }

    static fromJS(data: any): ProblemAbout {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemAbout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["problemID"] = this.problemID;
        data["problemName"] = this.problemName;
        data["problemDescription"] = this.problemDescription;
        data["taskType"] = this.taskType;
        data["taskSubType"] = this.taskSubType;
        data["problemSchemaVersion"] = this.problemSchemaVersion;
        data["problemVersion"] = this.problemVersion;
        return data;
    }
}

export interface IProblemAbout {
    problemID?: string | undefined;
    problemName?: string | undefined;
    problemDescription?: string | undefined;
    taskType?: string | undefined;
    taskSubType?: string | undefined;
    problemSchemaVersion?: string | undefined;
    problemVersion?: string | undefined;
}

export class ProblemInputs implements IProblemInputs {
    data?: ProblemData[] | undefined;
    performanceMetrics?: ProblemPerformanceMetric[] | undefined;

    constructor(data?: IProblemInputs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(ProblemData.fromJS(item));
            }
            if (data["performanceMetrics"] && data["performanceMetrics"].constructor === Array) {
                this.performanceMetrics = [];
                for (let item of data["performanceMetrics"])
                    this.performanceMetrics.push(ProblemPerformanceMetric.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProblemInputs {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemInputs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        if (this.performanceMetrics && this.performanceMetrics.constructor === Array) {
            data["performanceMetrics"] = [];
            for (let item of this.performanceMetrics)
                data["performanceMetrics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProblemInputs {
    data?: ProblemData[] | undefined;
    performanceMetrics?: ProblemPerformanceMetric[] | undefined;
}

export class ProblemData implements IProblemData {
    datasetID?: string | undefined;
    targets?: ProblemTarget[] | undefined;

    constructor(data?: IProblemData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.datasetID = data["datasetID"];
            if (data["targets"] && data["targets"].constructor === Array) {
                this.targets = [];
                for (let item of data["targets"])
                    this.targets.push(ProblemTarget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProblemData {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetID"] = this.datasetID;
        if (this.targets && this.targets.constructor === Array) {
            data["targets"] = [];
            for (let item of this.targets)
                data["targets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProblemData {
    datasetID?: string | undefined;
    targets?: ProblemTarget[] | undefined;
}

export class ProblemTarget implements IProblemTarget {
    targetIndex?: number | undefined;
    resID?: string | undefined;
    colIndex?: number | undefined;
    colName?: string | undefined;

    constructor(data?: IProblemTarget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetIndex = data["targetIndex"];
            this.resID = data["resID"];
            this.colIndex = data["colIndex"];
            this.colName = data["colName"];
        }
    }

    static fromJS(data: any): ProblemTarget {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemTarget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetIndex"] = this.targetIndex;
        data["resID"] = this.resID;
        data["colIndex"] = this.colIndex;
        data["colName"] = this.colName;
        return data;
    }
}

export interface IProblemTarget {
    targetIndex?: number | undefined;
    resID?: string | undefined;
    colIndex?: number | undefined;
    colName?: string | undefined;
}

export class ProblemPerformanceMetric implements IProblemPerformanceMetric {
    metric?: string | undefined;

    constructor(data?: IProblemPerformanceMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.metric = data["metric"];
        }
    }

    static fromJS(data: any): ProblemPerformanceMetric {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemPerformanceMetric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metric"] = this.metric;
        return data;
    }
}

export interface IProblemPerformanceMetric {
    metric?: string | undefined;
}

export class DarpaDatasetDoc implements IDarpaDatasetDoc {
    about?: DatasetAbout | undefined;
    dataResources?: Resource[] | undefined;

    constructor(data?: IDarpaDatasetDoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.about = data["about"] ? DatasetAbout.fromJS(data["about"]) : <any>undefined;
            if (data["dataResources"] && data["dataResources"].constructor === Array) {
                this.dataResources = [];
                for (let item of data["dataResources"])
                    this.dataResources.push(Resource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DarpaDatasetDoc {
        data = typeof data === 'object' ? data : {};
        let result = new DarpaDatasetDoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["about"] = this.about ? this.about.toJSON() : <any>undefined;
        if (this.dataResources && this.dataResources.constructor === Array) {
            data["dataResources"] = [];
            for (let item of this.dataResources)
                data["dataResources"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDarpaDatasetDoc {
    about?: DatasetAbout | undefined;
    dataResources?: Resource[] | undefined;
}

export class DatasetAbout implements IDatasetAbout {
    datasetID?: string | undefined;
    datasetName?: string | undefined;
    description?: string | undefined;
    citation?: string | undefined;
    license?: string | undefined;
    source?: string | undefined;
    sourceURI?: string | undefined;
    approximateSize?: string | undefined;
    datasetSchemaVersion?: string | undefined;
    redacted?: boolean | undefined;
    datasetVersion?: string | undefined;

    constructor(data?: IDatasetAbout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.datasetID = data["datasetID"];
            this.datasetName = data["datasetName"];
            this.description = data["description"];
            this.citation = data["citation"];
            this.license = data["license"];
            this.source = data["source"];
            this.sourceURI = data["sourceURI"];
            this.approximateSize = data["approximateSize"];
            this.datasetSchemaVersion = data["datasetSchemaVersion"];
            this.redacted = data["redacted"];
            this.datasetVersion = data["datasetVersion"];
        }
    }

    static fromJS(data: any): DatasetAbout {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetAbout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetID"] = this.datasetID;
        data["datasetName"] = this.datasetName;
        data["description"] = this.description;
        data["citation"] = this.citation;
        data["license"] = this.license;
        data["source"] = this.source;
        data["sourceURI"] = this.sourceURI;
        data["approximateSize"] = this.approximateSize;
        data["datasetSchemaVersion"] = this.datasetSchemaVersion;
        data["redacted"] = this.redacted;
        data["datasetVersion"] = this.datasetVersion;
        return data;
    }
}

export interface IDatasetAbout {
    datasetID?: string | undefined;
    datasetName?: string | undefined;
    description?: string | undefined;
    citation?: string | undefined;
    license?: string | undefined;
    source?: string | undefined;
    sourceURI?: string | undefined;
    approximateSize?: string | undefined;
    datasetSchemaVersion?: string | undefined;
    redacted?: boolean | undefined;
    datasetVersion?: string | undefined;
}

export class Resource implements IResource {
    resID?: string | undefined;
    resPath?: string | undefined;
    resType?: string | undefined;
    resFormat?: string[] | undefined;
    columns?: Column[] | undefined;
    isCollection?: boolean | undefined;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resID = data["resID"];
            this.resPath = data["resPath"];
            this.resType = data["resType"];
            if (data["resFormat"] && data["resFormat"].constructor === Array) {
                this.resFormat = [];
                for (let item of data["resFormat"])
                    this.resFormat.push(item);
            }
            if (data["columns"] && data["columns"].constructor === Array) {
                this.columns = [];
                for (let item of data["columns"])
                    this.columns.push(Column.fromJS(item));
            }
            this.isCollection = data["isCollection"];
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resID"] = this.resID;
        data["resPath"] = this.resPath;
        data["resType"] = this.resType;
        if (this.resFormat && this.resFormat.constructor === Array) {
            data["resFormat"] = [];
            for (let item of this.resFormat)
                data["resFormat"].push(item);
        }
        if (this.columns && this.columns.constructor === Array) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["isCollection"] = this.isCollection;
        return data;
    }
}

export interface IResource {
    resID?: string | undefined;
    resPath?: string | undefined;
    resType?: string | undefined;
    resFormat?: string[] | undefined;
    columns?: Column[] | undefined;
    isCollection?: boolean | undefined;
}

export class Column implements IColumn {
    colIndex?: number | undefined;
    colDescription?: string | undefined;
    colName?: string | undefined;
    colType?: string | undefined;
    role?: string[] | undefined;
    refersTo?: Reference | undefined;

    constructor(data?: IColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.colIndex = data["colIndex"];
            this.colDescription = data["colDescription"];
            this.colName = data["colName"];
            this.colType = data["colType"];
            if (data["role"] && data["role"].constructor === Array) {
                this.role = [];
                for (let item of data["role"])
                    this.role.push(item);
            }
            this.refersTo = data["refersTo"] ? Reference.fromJS(data["refersTo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Column {
        data = typeof data === 'object' ? data : {};
        let result = new Column();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colIndex"] = this.colIndex;
        data["colDescription"] = this.colDescription;
        data["colName"] = this.colName;
        data["colType"] = this.colType;
        if (this.role && this.role.constructor === Array) {
            data["role"] = [];
            for (let item of this.role)
                data["role"].push(item);
        }
        data["refersTo"] = this.refersTo ? this.refersTo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IColumn {
    colIndex?: number | undefined;
    colDescription?: string | undefined;
    colName?: string | undefined;
    colType?: string | undefined;
    role?: string[] | undefined;
    refersTo?: Reference | undefined;
}

export class Reference implements IReference {
    resID?: string | undefined;

    constructor(data?: IReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resID = data["resID"];
        }
    }

    static fromJS(data: any): Reference {
        data = typeof data === 'object' ? data : {};
        let result = new Reference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resID"] = this.resID;
        return data;
    }
}

export interface IReference {
    resID?: string | undefined;
}

export class ProblemFinderRows implements IProblemFinderRows {
    label?: string | undefined;
    type?: string | undefined;
    features?: Feature[] | undefined;

    constructor(data?: IProblemFinderRows) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.type = data["type"];
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(Feature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProblemFinderRows {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemFinderRows();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["type"] = this.type;
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProblemFinderRows {
    label?: string | undefined;
    type?: string | undefined;
    features?: Feature[] | undefined;
}

export class Feature implements IFeature {
    name?: string | undefined;
    selected?: boolean | undefined;
    value?: number | undefined;

    constructor(data?: IFeature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.selected = data["selected"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): Feature {
        data = typeof data === 'object' ? data : {};
        let result = new Feature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["selected"] = this.selected;
        data["value"] = this.value;
        return data;
    }
}

export interface IFeature {
    name?: string | undefined;
    selected?: boolean | undefined;
    value?: number | undefined;
}

export enum DataType2 {
    Int = 0,
    String = 1,
    Float = 2,
    Double = 3,
    DateTime = 4,
    Object = 5,
    Undefined = 6,
}

export abstract class DataTypeExtensions implements IDataTypeExtensions {

    constructor(data?: IDataTypeExtensions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): DataTypeExtensions {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DataTypeExtensions' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IDataTypeExtensions {
}

export class ResObject implements IResObject {
    columnName?: string | undefined;

    constructor(data?: IResObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.columnName = data["columnName"];
        }
    }

    static fromJS(data: any): ResObject {
        data = typeof data === 'object' ? data : {};
        let result = new ResObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        return data;
    }
}

export interface IResObject {
    columnName?: string | undefined;
}

export class Exception implements IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["Message"];
            this.innerException = data["InnerException"] ? Exception.fromJS(data["InnerException"]) : <any>undefined;
            this.stackTrace = data["StackTrace"];
            this.source = data["Source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Source"] = this.source;
        return data;
    }
}

export interface IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export class IDEAException extends Exception implements IIDEAException {

    constructor(data?: IIDEAException) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): IDEAException {
        data = typeof data === 'object' ? data : {};
        let result = new IDEAException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIDEAException extends IException {
}

export class CodeParameters implements ICodeParameters {
    attributeCodeParameters?: AttributeCodeParameters[] | undefined;
    adapterName?: string | undefined;

    constructor(data?: ICodeParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["AttributeCodeParameters"] && data["AttributeCodeParameters"].constructor === Array) {
                this.attributeCodeParameters = [];
                for (let item of data["AttributeCodeParameters"])
                    this.attributeCodeParameters.push(AttributeCodeParameters.fromJS(item));
            }
            this.adapterName = data["AdapterName"];
        }
    }

    static fromJS(data: any): CodeParameters {
        data = typeof data === 'object' ? data : {};
        let result = new CodeParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.attributeCodeParameters && this.attributeCodeParameters.constructor === Array) {
            data["AttributeCodeParameters"] = [];
            for (let item of this.attributeCodeParameters)
                data["AttributeCodeParameters"].push(item.toJSON());
        }
        data["AdapterName"] = this.adapterName;
        return data;
    }
}

export interface ICodeParameters {
    attributeCodeParameters?: AttributeCodeParameters[] | undefined;
    adapterName?: string | undefined;
}

export class CompileResult implements ICompileResult {
    compileSuccess?: boolean | undefined;
    compileMessage?: string | undefined;
    dataType?: DataType | undefined;
    replaceAttributeParameters?: AttributeParameters[] | undefined;

    constructor(data?: ICompileResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.compileSuccess = data["CompileSuccess"];
            this.compileMessage = data["CompileMessage"];
            this.dataType = data["DataType"];
            if (data["ReplaceAttributeParameters"] && data["ReplaceAttributeParameters"].constructor === Array) {
                this.replaceAttributeParameters = [];
                for (let item of data["ReplaceAttributeParameters"])
                    this.replaceAttributeParameters.push(AttributeParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompileResult {
        data = typeof data === 'object' ? data : {};
        let result = new CompileResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CompileSuccess"] = this.compileSuccess;
        data["CompileMessage"] = this.compileMessage;
        data["DataType"] = this.dataType;
        if (this.replaceAttributeParameters && this.replaceAttributeParameters.constructor === Array) {
            data["ReplaceAttributeParameters"] = [];
            for (let item of this.replaceAttributeParameters)
                data["ReplaceAttributeParameters"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompileResult {
    compileSuccess?: boolean | undefined;
    compileMessage?: string | undefined;
    dataType?: DataType | undefined;
    replaceAttributeParameters?: AttributeParameters[] | undefined;
}

export class CompileResults implements ICompileResults {
    rawNameToCompileResult?: { [key: string]: CompileResult; } | undefined;

    constructor(data?: ICompileResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["RawNameToCompileResult"]) {
                this.rawNameToCompileResult = {};
                for (let key in data["RawNameToCompileResult"]) {
                    if (data["RawNameToCompileResult"].hasOwnProperty(key))
                        this.rawNameToCompileResult[key] = data["RawNameToCompileResult"][key] ? CompileResult.fromJS(data["RawNameToCompileResult"][key]) : new CompileResult();
                }
            }
        }
    }

    static fromJS(data: any): CompileResults {
        data = typeof data === 'object' ? data : {};
        let result = new CompileResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.rawNameToCompileResult) {
            data["RawNameToCompileResult"] = {};
            for (let key in this.rawNameToCompileResult) {
                if (this.rawNameToCompileResult.hasOwnProperty(key))
                    data["RawNameToCompileResult"][key] = this.rawNameToCompileResult[key];
            }
        }
        return data;
    }
}

export interface ICompileResults {
    rawNameToCompileResult?: { [key: string]: CompileResult; } | undefined;
}

export abstract class UniqueJson implements IUniqueJson {

    constructor(data?: IUniqueJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): UniqueJson {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UniqueJson' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUniqueJson {
}

export abstract class OperationParameters extends UniqueJson implements IOperationParameters {
    isCachable?: boolean | undefined;

    protected _discriminator: string;

    constructor(data?: IOperationParameters) {
        super(data);
        this._discriminator = "OperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.isCachable = data["IsCachable"];
        }
    }

    static fromJS(data: any): OperationParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "DataOperationParameters") {
            throw new Error("The abstract class 'DataOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "ExampleOperationParameters") {
            let result = new ExampleOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "HistogramOperationParameters") {
            let result = new HistogramOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DistOperationParameters") {
            throw new Error("The abstract class 'DistOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "OptimizerOperationParameters") {
            let result = new OptimizerOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RawDataOperationParameters") {
            let result = new RawDataOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RecommenderOperationParameters") {
            let result = new RecommenderOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CDFOperationParameters") {
            let result = new CDFOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TestDistOperationParameters") {
            throw new Error("The abstract class 'TestDistOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "ChiSquaredTestOperationParameters") {
            let result = new ChiSquaredTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "HypothesisTestParameters") {
            throw new Error("The abstract class 'HypothesisTestParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "CorrelationTestOperationParameters") {
            let result = new CorrelationTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EmpiricalDistOperationParameters") {
            let result = new EmpiricalDistOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "KSTestOperationParameters") {
            let result = new KSTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "NewModelOperationParameters") {
            let result = new NewModelOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ModelOperationParameters") {
            throw new Error("The abstract class 'ModelOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "RootMeanSquareTestOperationParameters") {
            let result = new RootMeanSquareTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TTestOperationParameters") {
            let result = new TTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FeatureImportanceOperationParameters") {
            let result = new FeatureImportanceOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SampleOperationParameters") {
            let result = new SampleOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AddComparisonParameters") {
            let result = new AddComparisonParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "GetModelStateParameters") {
            let result = new GetModelStateParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FrequentItemsetOperationParameters") {
            let result = new FrequentItemsetOperationParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'OperationParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["IsCachable"] = this.isCachable;
        super.toJSON(data);
        return data;
    }
}

export interface IOperationParameters extends IUniqueJson {
    isCachable?: boolean | undefined;
}

export abstract class DataOperationParameters extends OperationParameters implements IDataOperationParameters {
    sampleStreamBlockSize?: number | undefined;
    adapterName?: string | undefined;
    isCachable?: boolean | undefined;

    constructor(data?: IDataOperationParameters) {
        super(data);
        this._discriminator = "DataOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.sampleStreamBlockSize = data["SampleStreamBlockSize"];
            this.adapterName = data["AdapterName"];
            this.isCachable = data["IsCachable"];
        }
    }

    static fromJS(data: any): DataOperationParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "ExampleOperationParameters") {
            let result = new ExampleOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "HistogramOperationParameters") {
            let result = new HistogramOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DistOperationParameters") {
            throw new Error("The abstract class 'DistOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "OptimizerOperationParameters") {
            let result = new OptimizerOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RawDataOperationParameters") {
            let result = new RawDataOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RecommenderOperationParameters") {
            let result = new RecommenderOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CDFOperationParameters") {
            let result = new CDFOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TestDistOperationParameters") {
            throw new Error("The abstract class 'TestDistOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "EmpiricalDistOperationParameters") {
            let result = new EmpiricalDistOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FeatureImportanceOperationParameters") {
            let result = new FeatureImportanceOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SampleOperationParameters") {
            let result = new SampleOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FrequentItemsetOperationParameters") {
            let result = new FrequentItemsetOperationParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DataOperationParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SampleStreamBlockSize"] = this.sampleStreamBlockSize;
        data["AdapterName"] = this.adapterName;
        data["IsCachable"] = this.isCachable;
        super.toJSON(data);
        return data;
    }
}

export interface IDataOperationParameters extends IOperationParameters {
    sampleStreamBlockSize?: number | undefined;
    adapterName?: string | undefined;
    isCachable?: boolean | undefined;
}

export class ExampleOperationParameters extends DataOperationParameters implements IExampleOperationParameters {
    filter?: string | undefined;
    attributeParameters?: AttributeParameters[] | undefined;
    attributeCodeParameters?: AttributeCaclculatedParameters[] | undefined;
    dummyValue?: number | undefined;
    exampleType?: string | undefined;

    constructor(data?: IExampleOperationParameters) {
        super(data);
        this._discriminator = "ExampleOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["Filter"];
            if (data["AttributeParameters"] && data["AttributeParameters"].constructor === Array) {
                this.attributeParameters = [];
                for (let item of data["AttributeParameters"])
                    this.attributeParameters.push(AttributeParameters.fromJS(item));
            }
            if (data["AttributeCodeParameters"] && data["AttributeCodeParameters"].constructor === Array) {
                this.attributeCodeParameters = [];
                for (let item of data["AttributeCodeParameters"])
                    this.attributeCodeParameters.push(AttributeCaclculatedParameters.fromJS(item));
            }
            this.dummyValue = data["DummyValue"];
            this.exampleType = data["ExampleType"];
        }
    }

    static fromJS(data: any): ExampleOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ExampleOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter;
        if (this.attributeParameters && this.attributeParameters.constructor === Array) {
            data["AttributeParameters"] = [];
            for (let item of this.attributeParameters)
                data["AttributeParameters"].push(item.toJSON());
        }
        if (this.attributeCodeParameters && this.attributeCodeParameters.constructor === Array) {
            data["AttributeCodeParameters"] = [];
            for (let item of this.attributeCodeParameters)
                data["AttributeCodeParameters"].push(item.toJSON());
        }
        data["DummyValue"] = this.dummyValue;
        data["ExampleType"] = this.exampleType;
        super.toJSON(data);
        return data;
    }
}

export interface IExampleOperationParameters extends IDataOperationParameters {
    filter?: string | undefined;
    attributeParameters?: AttributeParameters[] | undefined;
    attributeCodeParameters?: AttributeCaclculatedParameters[] | undefined;
    dummyValue?: number | undefined;
    exampleType?: string | undefined;
}

export abstract class DistOperationParameters extends DataOperationParameters implements IDistOperationParameters {
    filter?: string | undefined;
    attributeCalculatedParameters?: AttributeCaclculatedParameters[] | undefined;

    constructor(data?: IDistOperationParameters) {
        super(data);
        this._discriminator = "DistOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["Filter"];
            if (data["AttributeCalculatedParameters"] && data["AttributeCalculatedParameters"].constructor === Array) {
                this.attributeCalculatedParameters = [];
                for (let item of data["AttributeCalculatedParameters"])
                    this.attributeCalculatedParameters.push(AttributeCaclculatedParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DistOperationParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "HistogramOperationParameters") {
            let result = new HistogramOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "OptimizerOperationParameters") {
            let result = new OptimizerOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RawDataOperationParameters") {
            let result = new RawDataOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CDFOperationParameters") {
            let result = new CDFOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TestDistOperationParameters") {
            throw new Error("The abstract class 'TestDistOperationParameters' cannot be instantiated.");
        }
        if (data["discriminator"] === "EmpiricalDistOperationParameters") {
            let result = new EmpiricalDistOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FeatureImportanceOperationParameters") {
            let result = new FeatureImportanceOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SampleOperationParameters") {
            let result = new SampleOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FrequentItemsetOperationParameters") {
            let result = new FrequentItemsetOperationParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DistOperationParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter;
        if (this.attributeCalculatedParameters && this.attributeCalculatedParameters.constructor === Array) {
            data["AttributeCalculatedParameters"] = [];
            for (let item of this.attributeCalculatedParameters)
                data["AttributeCalculatedParameters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDistOperationParameters extends IDataOperationParameters {
    filter?: string | undefined;
    attributeCalculatedParameters?: AttributeCaclculatedParameters[] | undefined;
}

export class HistogramOperationParameters extends DistOperationParameters implements IHistogramOperationParameters {
    sortPerBinAggregateParameter?: AggregateParameters | undefined;
    binningParameters?: BinningParameters[] | undefined;
    perBinAggregateParameters?: AggregateParameters[] | undefined;
    globalAggregateParameters?: AggregateParameters[] | undefined;
    brushes?: string[] | undefined;
    enableBrushComputation?: boolean | undefined;
    degreeOfParallism?: number | undefined;

    constructor(data?: IHistogramOperationParameters) {
        super(data);
        this._discriminator = "HistogramOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.sortPerBinAggregateParameter = data["SortPerBinAggregateParameter"] ? AggregateParameters.fromJS(data["SortPerBinAggregateParameter"]) : <any>undefined;
            if (data["BinningParameters"] && data["BinningParameters"].constructor === Array) {
                this.binningParameters = [];
                for (let item of data["BinningParameters"])
                    this.binningParameters.push(BinningParameters.fromJS(item));
            }
            if (data["PerBinAggregateParameters"] && data["PerBinAggregateParameters"].constructor === Array) {
                this.perBinAggregateParameters = [];
                for (let item of data["PerBinAggregateParameters"])
                    this.perBinAggregateParameters.push(AggregateParameters.fromJS(item));
            }
            if (data["GlobalAggregateParameters"] && data["GlobalAggregateParameters"].constructor === Array) {
                this.globalAggregateParameters = [];
                for (let item of data["GlobalAggregateParameters"])
                    this.globalAggregateParameters.push(AggregateParameters.fromJS(item));
            }
            if (data["Brushes"] && data["Brushes"].constructor === Array) {
                this.brushes = [];
                for (let item of data["Brushes"])
                    this.brushes.push(item);
            }
            this.enableBrushComputation = data["EnableBrushComputation"];
            this.degreeOfParallism = data["DegreeOfParallism"];
        }
    }

    static fromJS(data: any): HistogramOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new HistogramOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SortPerBinAggregateParameter"] = this.sortPerBinAggregateParameter ? this.sortPerBinAggregateParameter.toJSON() : <any>undefined;
        if (this.binningParameters && this.binningParameters.constructor === Array) {
            data["BinningParameters"] = [];
            for (let item of this.binningParameters)
                data["BinningParameters"].push(item.toJSON());
        }
        if (this.perBinAggregateParameters && this.perBinAggregateParameters.constructor === Array) {
            data["PerBinAggregateParameters"] = [];
            for (let item of this.perBinAggregateParameters)
                data["PerBinAggregateParameters"].push(item.toJSON());
        }
        if (this.globalAggregateParameters && this.globalAggregateParameters.constructor === Array) {
            data["GlobalAggregateParameters"] = [];
            for (let item of this.globalAggregateParameters)
                data["GlobalAggregateParameters"].push(item.toJSON());
        }
        if (this.brushes && this.brushes.constructor === Array) {
            data["Brushes"] = [];
            for (let item of this.brushes)
                data["Brushes"].push(item);
        }
        data["EnableBrushComputation"] = this.enableBrushComputation;
        data["DegreeOfParallism"] = this.degreeOfParallism;
        super.toJSON(data);
        return data;
    }
}

export interface IHistogramOperationParameters extends IDistOperationParameters {
    sortPerBinAggregateParameter?: AggregateParameters | undefined;
    binningParameters?: BinningParameters[] | undefined;
    perBinAggregateParameters?: AggregateParameters[] | undefined;
    globalAggregateParameters?: AggregateParameters[] | undefined;
    brushes?: string[] | undefined;
    enableBrushComputation?: boolean | undefined;
    degreeOfParallism?: number | undefined;
}

export class OptimizerOperationParameters extends DistOperationParameters implements IOptimizerOperationParameters {
    taskType?: TaskType | undefined;
    taskSubType?: TaskSubType | undefined;
    metricType?: MetricType | undefined;
    labelAttribute?: AttributeParameters | undefined;
    featureAttributes?: AttributeParameters[] | undefined;
    requiredPrimitives?: string[] | undefined;
    pythonFilter?: string | undefined;
    trainFilter?: string | undefined;
    pythonTrainFilter?: string | undefined;
    testFilter?: string | undefined;
    pythonTestFilter?: string | undefined;

    constructor(data?: IOptimizerOperationParameters) {
        super(data);
        this._discriminator = "OptimizerOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.taskType = data["TaskType"];
            this.taskSubType = data["TaskSubType"];
            this.metricType = data["MetricType"];
            this.labelAttribute = data["LabelAttribute"] ? AttributeParameters.fromJS(data["LabelAttribute"]) : <any>undefined;
            if (data["FeatureAttributes"] && data["FeatureAttributes"].constructor === Array) {
                this.featureAttributes = [];
                for (let item of data["FeatureAttributes"])
                    this.featureAttributes.push(AttributeParameters.fromJS(item));
            }
            if (data["RequiredPrimitives"] && data["RequiredPrimitives"].constructor === Array) {
                this.requiredPrimitives = [];
                for (let item of data["RequiredPrimitives"])
                    this.requiredPrimitives.push(item);
            }
            this.pythonFilter = data["PythonFilter"];
            this.trainFilter = data["TrainFilter"];
            this.pythonTrainFilter = data["PythonTrainFilter"];
            this.testFilter = data["TestFilter"];
            this.pythonTestFilter = data["PythonTestFilter"];
        }
    }

    static fromJS(data: any): OptimizerOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new OptimizerOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TaskType"] = this.taskType;
        data["TaskSubType"] = this.taskSubType;
        data["MetricType"] = this.metricType;
        data["LabelAttribute"] = this.labelAttribute ? this.labelAttribute.toJSON() : <any>undefined;
        if (this.featureAttributes && this.featureAttributes.constructor === Array) {
            data["FeatureAttributes"] = [];
            for (let item of this.featureAttributes)
                data["FeatureAttributes"].push(item.toJSON());
        }
        if (this.requiredPrimitives && this.requiredPrimitives.constructor === Array) {
            data["RequiredPrimitives"] = [];
            for (let item of this.requiredPrimitives)
                data["RequiredPrimitives"].push(item);
        }
        data["PythonFilter"] = this.pythonFilter;
        data["TrainFilter"] = this.trainFilter;
        data["PythonTrainFilter"] = this.pythonTrainFilter;
        data["TestFilter"] = this.testFilter;
        data["PythonTestFilter"] = this.pythonTestFilter;
        super.toJSON(data);
        return data;
    }
}

export interface IOptimizerOperationParameters extends IDistOperationParameters {
    taskType?: TaskType | undefined;
    taskSubType?: TaskSubType | undefined;
    metricType?: MetricType | undefined;
    labelAttribute?: AttributeParameters | undefined;
    featureAttributes?: AttributeParameters[] | undefined;
    requiredPrimitives?: string[] | undefined;
    pythonFilter?: string | undefined;
    trainFilter?: string | undefined;
    pythonTrainFilter?: string | undefined;
    testFilter?: string | undefined;
    pythonTestFilter?: string | undefined;
}

export enum TaskType {
    Undefined = 0,
    Classification = 1,
    Regression = 2,
    Clustering = 3,
    LinkPrediction = 4,
    VertexNomination = 5,
    CommunityDetection = 6,
    GraphClustering = 7,
    GraphMatching = 8,
    TimeSeriesForecasting = 9,
    CollaborativeFiltering = 10,
}

export enum TaskSubType {
    Undefined = 0,
    None = 1,
    Binary = 2,
    Multiclass = 3,
    Multilabel = 4,
    Univariate = 5,
    Multivariate = 6,
    Overlapping = 7,
    Nonoverlapping = 8,
}

export enum MetricType {
    MetricUndefined = 0,
    Accuracy = 1,
    Precision = 2,
    Recall = 3,
    F1 = 4,
    F1Micro = 5,
    F1Macro = 6,
    RocAuc = 7,
    RocAucMicro = 8,
    RocAucMacro = 9,
    MeanSquaredError = 10,
    RootMeanSquaredError = 11,
    RootMeanSquaredErrorAvg = 12,
    MeanAbsoluteError = 13,
    RSquared = 14,
    NormalizedMutualInformation = 15,
    JaccardSimilarityScore = 16,
    PrecisionAtTopK = 17,
    ObjectDetectionAveragePrecision = 18,
    Loss = 100,
}

export class RawDataOperationParameters extends DistOperationParameters implements IRawDataOperationParameters {
    sortUpRawName?: string | undefined;
    sortDownRawName?: string | undefined;
    numRecords?: number | undefined;
    binningParameters?: BinningParameters[] | undefined;
    brushes?: string[] | undefined;
    enableBrushComputation?: boolean | undefined;

    constructor(data?: IRawDataOperationParameters) {
        super(data);
        this._discriminator = "RawDataOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.sortUpRawName = data["SortUpRawName"];
            this.sortDownRawName = data["SortDownRawName"];
            this.numRecords = data["NumRecords"];
            if (data["BinningParameters"] && data["BinningParameters"].constructor === Array) {
                this.binningParameters = [];
                for (let item of data["BinningParameters"])
                    this.binningParameters.push(BinningParameters.fromJS(item));
            }
            if (data["Brushes"] && data["Brushes"].constructor === Array) {
                this.brushes = [];
                for (let item of data["Brushes"])
                    this.brushes.push(item);
            }
            this.enableBrushComputation = data["EnableBrushComputation"];
        }
    }

    static fromJS(data: any): RawDataOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new RawDataOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SortUpRawName"] = this.sortUpRawName;
        data["SortDownRawName"] = this.sortDownRawName;
        data["NumRecords"] = this.numRecords;
        if (this.binningParameters && this.binningParameters.constructor === Array) {
            data["BinningParameters"] = [];
            for (let item of this.binningParameters)
                data["BinningParameters"].push(item.toJSON());
        }
        if (this.brushes && this.brushes.constructor === Array) {
            data["Brushes"] = [];
            for (let item of this.brushes)
                data["Brushes"].push(item);
        }
        data["EnableBrushComputation"] = this.enableBrushComputation;
        super.toJSON(data);
        return data;
    }
}

export interface IRawDataOperationParameters extends IDistOperationParameters {
    sortUpRawName?: string | undefined;
    sortDownRawName?: string | undefined;
    numRecords?: number | undefined;
    binningParameters?: BinningParameters[] | undefined;
    brushes?: string[] | undefined;
    enableBrushComputation?: boolean | undefined;
}

export class RecommenderOperationParameters extends DataOperationParameters implements IRecommenderOperationParameters {
    target?: HistogramOperationParameters | undefined;
    budget?: number | undefined;
    modelId?: ModelId | undefined;
    includeAttributeParameters?: AttributeParameters[] | undefined;
    excludeAttributeParameters?: AttributeParameters[] | undefined;
    riskControlType?: RiskControlType | undefined;

    constructor(data?: IRecommenderOperationParameters) {
        super(data);
        this._discriminator = "RecommenderOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.target = data["Target"] ? HistogramOperationParameters.fromJS(data["Target"]) : <any>undefined;
            this.budget = data["Budget"];
            this.modelId = data["ModelId"] ? ModelId.fromJS(data["ModelId"]) : <any>undefined;
            if (data["IncludeAttributeParameters"] && data["IncludeAttributeParameters"].constructor === Array) {
                this.includeAttributeParameters = [];
                for (let item of data["IncludeAttributeParameters"])
                    this.includeAttributeParameters.push(AttributeParameters.fromJS(item));
            }
            if (data["ExcludeAttributeParameters"] && data["ExcludeAttributeParameters"].constructor === Array) {
                this.excludeAttributeParameters = [];
                for (let item of data["ExcludeAttributeParameters"])
                    this.excludeAttributeParameters.push(AttributeParameters.fromJS(item));
            }
            this.riskControlType = data["RiskControlType"];
        }
    }

    static fromJS(data: any): RecommenderOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new RecommenderOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target ? this.target.toJSON() : <any>undefined;
        data["Budget"] = this.budget;
        data["ModelId"] = this.modelId ? this.modelId.toJSON() : <any>undefined;
        if (this.includeAttributeParameters && this.includeAttributeParameters.constructor === Array) {
            data["IncludeAttributeParameters"] = [];
            for (let item of this.includeAttributeParameters)
                data["IncludeAttributeParameters"].push(item.toJSON());
        }
        if (this.excludeAttributeParameters && this.excludeAttributeParameters.constructor === Array) {
            data["ExcludeAttributeParameters"] = [];
            for (let item of this.excludeAttributeParameters)
                data["ExcludeAttributeParameters"].push(item.toJSON());
        }
        data["RiskControlType"] = this.riskControlType;
        super.toJSON(data);
        return data;
    }
}

export interface IRecommenderOperationParameters extends IDataOperationParameters {
    target?: HistogramOperationParameters | undefined;
    budget?: number | undefined;
    modelId?: ModelId | undefined;
    includeAttributeParameters?: AttributeParameters[] | undefined;
    excludeAttributeParameters?: AttributeParameters[] | undefined;
    riskControlType?: RiskControlType | undefined;
}

export class ModelId implements IModelId {
    value?: string | undefined;

    constructor(data?: IModelId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): ModelId {
        data = typeof data === 'object' ? data : {};
        let result = new ModelId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        return data;
    }
}

export interface IModelId {
    value?: string | undefined;
}

export enum RiskControlType {
    PCER = 0,
    Bonferroni = 1,
    AdaBonferroni = 2,
    HolmBonferroni = 3,
    BHFDR = 4,
    SeqFDR = 5,
    AlphaFDR = 6,
    BestFootForward = 7,
    BetaFarsighted = 8,
    BetaFarsightedWithSupport = 9,
    GammaFixed = 10,
    DeltaHopeful = 11,
    EpsilonHybrid = 12,
    EpsilonHybridWithoutSupport = 13,
    PsiSupport = 14,
    ZetaDynamic = 15,
    Unknown = 16,
}

export abstract class TestDistOperationParameters extends DistOperationParameters implements ITestDistOperationParameters {
    attributeParameters?: AttributeParameters[] | undefined;

    constructor(data?: ITestDistOperationParameters) {
        super(data);
        this._discriminator = "TestDistOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["AttributeParameters"] && data["AttributeParameters"].constructor === Array) {
                this.attributeParameters = [];
                for (let item of data["AttributeParameters"])
                    this.attributeParameters.push(AttributeParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestDistOperationParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "CDFOperationParameters") {
            let result = new CDFOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EmpiricalDistOperationParameters") {
            let result = new EmpiricalDistOperationParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TestDistOperationParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.attributeParameters && this.attributeParameters.constructor === Array) {
            data["AttributeParameters"] = [];
            for (let item of this.attributeParameters)
                data["AttributeParameters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITestDistOperationParameters extends IDistOperationParameters {
    attributeParameters?: AttributeParameters[] | undefined;
}

export class CDFOperationParameters extends TestDistOperationParameters implements ICDFOperationParameters {

    constructor(data?: ICDFOperationParameters) {
        super(data);
        this._discriminator = "CDFOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CDFOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new CDFOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICDFOperationParameters extends ITestDistOperationParameters {
}

export abstract class HypothesisTestParameters extends OperationParameters implements IHypothesisTestParameters {
    childOperationParameters?: OperationParameters[] | undefined;
    isCachable?: boolean | undefined;

    constructor(data?: IHypothesisTestParameters) {
        super(data);
        this._discriminator = "HypothesisTestParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ChildOperationParameters"] && data["ChildOperationParameters"].constructor === Array) {
                this.childOperationParameters = [];
                for (let item of data["ChildOperationParameters"])
                    this.childOperationParameters.push(OperationParameters.fromJS(item));
            }
            this.isCachable = data["IsCachable"];
        }
    }

    static fromJS(data: any): HypothesisTestParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "ChiSquaredTestOperationParameters") {
            let result = new ChiSquaredTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CorrelationTestOperationParameters") {
            let result = new CorrelationTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "KSTestOperationParameters") {
            let result = new KSTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RootMeanSquareTestOperationParameters") {
            let result = new RootMeanSquareTestOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TTestOperationParameters") {
            let result = new TTestOperationParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'HypothesisTestParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.childOperationParameters && this.childOperationParameters.constructor === Array) {
            data["ChildOperationParameters"] = [];
            for (let item of this.childOperationParameters)
                data["ChildOperationParameters"].push(item.toJSON());
        }
        data["IsCachable"] = this.isCachable;
        super.toJSON(data);
        return data;
    }
}

export interface IHypothesisTestParameters extends IOperationParameters {
    childOperationParameters?: OperationParameters[] | undefined;
    isCachable?: boolean | undefined;
}

export class ChiSquaredTestOperationParameters extends HypothesisTestParameters implements IChiSquaredTestOperationParameters {

    constructor(data?: IChiSquaredTestOperationParameters) {
        super(data);
        this._discriminator = "ChiSquaredTestOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ChiSquaredTestOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ChiSquaredTestOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IChiSquaredTestOperationParameters extends IHypothesisTestParameters {
}

export class CorrelationTestOperationParameters extends HypothesisTestParameters implements ICorrelationTestOperationParameters {

    constructor(data?: ICorrelationTestOperationParameters) {
        super(data);
        this._discriminator = "CorrelationTestOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): CorrelationTestOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new CorrelationTestOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICorrelationTestOperationParameters extends IHypothesisTestParameters {
}

export class SubmitProblemParameters implements ISubmitProblemParameters {
    id?: string | undefined;

    constructor(data?: ISubmitProblemParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): SubmitProblemParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitProblemParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        return data;
    }
}

export interface ISubmitProblemParameters {
    id?: string | undefined;
}

export class SpecifyProblemParameters implements ISpecifyProblemParameters {
    id?: string | undefined;
    userComment?: string | undefined;
    optimizerOperationParameters?: OptimizerOperationParameters | undefined;

    constructor(data?: ISpecifyProblemParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.userComment = data["UserComment"];
            this.optimizerOperationParameters = data["OptimizerOperationParameters"] ? OptimizerOperationParameters.fromJS(data["OptimizerOperationParameters"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SpecifyProblemParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SpecifyProblemParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserComment"] = this.userComment;
        data["OptimizerOperationParameters"] = this.optimizerOperationParameters ? this.optimizerOperationParameters.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISpecifyProblemParameters {
    id?: string | undefined;
    userComment?: string | undefined;
    optimizerOperationParameters?: OptimizerOperationParameters | undefined;
}

export class EmpiricalDistOperationParameters extends TestDistOperationParameters implements IEmpiricalDistOperationParameters {
    keepSamples?: boolean | undefined;

    constructor(data?: IEmpiricalDistOperationParameters) {
        super(data);
        this._discriminator = "EmpiricalDistOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.keepSamples = data["KeepSamples"];
        }
    }

    static fromJS(data: any): EmpiricalDistOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new EmpiricalDistOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["KeepSamples"] = this.keepSamples;
        super.toJSON(data);
        return data;
    }
}

export interface IEmpiricalDistOperationParameters extends ITestDistOperationParameters {
    keepSamples?: boolean | undefined;
}

export class KSTestOperationParameters extends HypothesisTestParameters implements IKSTestOperationParameters {

    constructor(data?: IKSTestOperationParameters) {
        super(data);
        this._discriminator = "KSTestOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): KSTestOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new KSTestOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IKSTestOperationParameters extends IHypothesisTestParameters {
}

export abstract class ModelOperationParameters extends OperationParameters implements IModelOperationParameters {

    constructor(data?: IModelOperationParameters) {
        super(data);
        this._discriminator = "ModelOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): ModelOperationParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "NewModelOperationParameters") {
            let result = new NewModelOperationParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AddComparisonParameters") {
            let result = new AddComparisonParameters();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "GetModelStateParameters") {
            let result = new GetModelStateParameters();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ModelOperationParameters' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IModelOperationParameters extends IOperationParameters {
}

export class NewModelOperationParameters extends ModelOperationParameters implements INewModelOperationParameters {
    riskControlTypes?: RiskControlType[] | undefined;
    alpha?: number | undefined;
    alphaInvestParameter?: AlphaInvestParameter | undefined;

    constructor(data?: INewModelOperationParameters) {
        super(data);
        this._discriminator = "NewModelOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["RiskControlTypes"] && data["RiskControlTypes"].constructor === Array) {
                this.riskControlTypes = [];
                for (let item of data["RiskControlTypes"])
                    this.riskControlTypes.push(item);
            }
            this.alpha = data["Alpha"];
            this.alphaInvestParameter = data["AlphaInvestParameter"] ? AlphaInvestParameter.fromJS(data["AlphaInvestParameter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewModelOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new NewModelOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.riskControlTypes && this.riskControlTypes.constructor === Array) {
            data["RiskControlTypes"] = [];
            for (let item of this.riskControlTypes)
                data["RiskControlTypes"].push(item);
        }
        data["Alpha"] = this.alpha;
        data["AlphaInvestParameter"] = this.alphaInvestParameter ? this.alphaInvestParameter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface INewModelOperationParameters extends IModelOperationParameters {
    riskControlTypes?: RiskControlType[] | undefined;
    alpha?: number | undefined;
    alphaInvestParameter?: AlphaInvestParameter | undefined;
}

export class AlphaInvestParameter extends UniqueJson implements IAlphaInvestParameter {
    beta?: number | undefined;
    gamma?: number | undefined;
    delta?: number | undefined;
    epsilon?: number | undefined;
    windowSize?: number | undefined;
    psi?: number | undefined;

    constructor(data?: IAlphaInvestParameter) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.beta = data["Beta"];
            this.gamma = data["Gamma"];
            this.delta = data["Delta"];
            this.epsilon = data["Epsilon"];
            this.windowSize = data["WindowSize"];
            this.psi = data["Psi"];
        }
    }

    static fromJS(data: any): AlphaInvestParameter {
        data = typeof data === 'object' ? data : {};
        let result = new AlphaInvestParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Beta"] = this.beta;
        data["Gamma"] = this.gamma;
        data["Delta"] = this.delta;
        data["Epsilon"] = this.epsilon;
        data["WindowSize"] = this.windowSize;
        data["Psi"] = this.psi;
        super.toJSON(data);
        return data;
    }
}

export interface IAlphaInvestParameter extends IUniqueJson {
    beta?: number | undefined;
    gamma?: number | undefined;
    delta?: number | undefined;
    epsilon?: number | undefined;
    windowSize?: number | undefined;
    psi?: number | undefined;
}

export class RootMeanSquareTestOperationParameters extends HypothesisTestParameters implements IRootMeanSquareTestOperationParameters {
    seeded?: boolean | undefined;
    pValueConvergenceThreshold?: number | undefined;
    maxSimulationBatchCount?: number | undefined;
    perBatchSimulationCount?: number | undefined;

    constructor(data?: IRootMeanSquareTestOperationParameters) {
        super(data);
        this._discriminator = "RootMeanSquareTestOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.seeded = data["Seeded"];
            this.pValueConvergenceThreshold = data["PValueConvergenceThreshold"];
            this.maxSimulationBatchCount = data["MaxSimulationBatchCount"];
            this.perBatchSimulationCount = data["PerBatchSimulationCount"];
        }
    }

    static fromJS(data: any): RootMeanSquareTestOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new RootMeanSquareTestOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Seeded"] = this.seeded;
        data["PValueConvergenceThreshold"] = this.pValueConvergenceThreshold;
        data["MaxSimulationBatchCount"] = this.maxSimulationBatchCount;
        data["PerBatchSimulationCount"] = this.perBatchSimulationCount;
        super.toJSON(data);
        return data;
    }
}

export interface IRootMeanSquareTestOperationParameters extends IHypothesisTestParameters {
    seeded?: boolean | undefined;
    pValueConvergenceThreshold?: number | undefined;
    maxSimulationBatchCount?: number | undefined;
    perBatchSimulationCount?: number | undefined;
}

export class TTestOperationParameters extends HypothesisTestParameters implements ITTestOperationParameters {

    constructor(data?: ITTestOperationParameters) {
        super(data);
        this._discriminator = "TTestOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): TTestOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new TTestOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ITTestOperationParameters extends IHypothesisTestParameters {
}

export enum EffectSize {
    Small = 1,
    Meduim = 2,
    Large = 4,
}

export abstract class Result extends UniqueJson implements IResult {
    progress?: number | undefined;

    protected _discriminator: string;

    constructor(data?: IResult) {
        super(data);
        this._discriminator = "Result";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.progress = data["Progress"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "ErrorResult") {
            let result = new ErrorResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "HistogramResult") {
            let result = new HistogramResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DistResult") {
            throw new Error("The abstract class 'DistResult' cannot be instantiated.");
        }
        if (data["discriminator"] === "ModelWealthResult") {
            let result = new ModelWealthResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "HypothesisTestResult") {
            throw new Error("The abstract class 'HypothesisTestResult' cannot be instantiated.");
        }
        if (data["discriminator"] === "ModelOperationResult") {
            throw new Error("The abstract class 'ModelOperationResult' cannot be instantiated.");
        }
        if (data["discriminator"] === "RecommenderResult") {
            let result = new RecommenderResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "Decision") {
            let result = new Decision();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "OptimizerResult") {
            let result = new OptimizerResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ExampleResult") {
            let result = new ExampleResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "NewModelOperationResult") {
            let result = new NewModelOperationResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AddComparisonResult") {
            let result = new AddComparisonResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "GetModelStateResult") {
            let result = new GetModelStateResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FeatureImportanceResult") {
            let result = new FeatureImportanceResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RawDataResult") {
            let result = new RawDataResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SampleResult") {
            let result = new SampleResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CDFResult") {
            let result = new CDFResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ChiSquaredTestResult") {
            let result = new ChiSquaredTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CorrelationTestResult") {
            let result = new CorrelationTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EmpiricalDistResult") {
            let result = new EmpiricalDistResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "KSTestResult") {
            let result = new KSTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RootMeanSquareTestResult") {
            let result = new RootMeanSquareTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TTestResult") {
            let result = new TTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FrequentItemsetResult") {
            let result = new FrequentItemsetResult();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Result' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["Progress"] = this.progress;
        super.toJSON(data);
        return data;
    }
}

export interface IResult extends IUniqueJson {
    progress?: number | undefined;
}

export class ErrorResult extends Result implements IErrorResult {
    message?: string | undefined;

    constructor(data?: IErrorResult) {
        super(data);
        this._discriminator = "ErrorResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): ErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        super.toJSON(data);
        return data;
    }
}

export interface IErrorResult extends IResult {
    message?: string | undefined;
}

export abstract class DistResult extends Result implements IDistResult {
    sampleSize?: number | undefined;
    populationSize?: number | undefined;

    constructor(data?: IDistResult) {
        super(data);
        this._discriminator = "DistResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.sampleSize = data["SampleSize"];
            this.populationSize = data["PopulationSize"];
        }
    }

    static fromJS(data: any): DistResult {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "HistogramResult") {
            let result = new HistogramResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RawDataResult") {
            let result = new RawDataResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SampleResult") {
            let result = new SampleResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CDFResult") {
            let result = new CDFResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "EmpiricalDistResult") {
            let result = new EmpiricalDistResult();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'DistResult' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SampleSize"] = this.sampleSize;
        data["PopulationSize"] = this.populationSize;
        super.toJSON(data);
        return data;
    }
}

export interface IDistResult extends IResult {
    sampleSize?: number | undefined;
    populationSize?: number | undefined;
}

export class HistogramResult extends DistResult implements IHistogramResult {
    aggregateResults?: AggregateResult[][] | undefined;
    isEmpty?: boolean | undefined;
    brushes?: Brush[] | undefined;
    binRanges?: BinRange[] | undefined;
    aggregateParameters?: AggregateParameters[] | undefined;
    nullValueCount?: number | undefined;
    bins?: { [key: string]: Bin; } | undefined;

    constructor(data?: IHistogramResult) {
        super(data);
        this._discriminator = "HistogramResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["AggregateResults"] && data["AggregateResults"].constructor === Array) {
                this.aggregateResults = [];
                for (let item of data["AggregateResults"])
                    this.aggregateResults.push(item);
            }
            this.isEmpty = data["IsEmpty"];
            if (data["Brushes"] && data["Brushes"].constructor === Array) {
                this.brushes = [];
                for (let item of data["Brushes"])
                    this.brushes.push(Brush.fromJS(item));
            }
            if (data["BinRanges"] && data["BinRanges"].constructor === Array) {
                this.binRanges = [];
                for (let item of data["BinRanges"])
                    this.binRanges.push(BinRange.fromJS(item));
            }
            if (data["AggregateParameters"] && data["AggregateParameters"].constructor === Array) {
                this.aggregateParameters = [];
                for (let item of data["AggregateParameters"])
                    this.aggregateParameters.push(AggregateParameters.fromJS(item));
            }
            this.nullValueCount = data["NullValueCount"];
            if (data["Bins"]) {
                this.bins = {};
                for (let key in data["Bins"]) {
                    if (data["Bins"].hasOwnProperty(key))
                        this.bins[key] = data["Bins"][key] ? Bin.fromJS(data["Bins"][key]) : new Bin();
                }
            }
        }
    }

    static fromJS(data: any): HistogramResult {
        data = typeof data === 'object' ? data : {};
        let result = new HistogramResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregateResults && this.aggregateResults.constructor === Array) {
            data["AggregateResults"] = [];
            for (let item of this.aggregateResults)
                data["AggregateResults"].push(item);
        }
        data["IsEmpty"] = this.isEmpty;
        if (this.brushes && this.brushes.constructor === Array) {
            data["Brushes"] = [];
            for (let item of this.brushes)
                data["Brushes"].push(item.toJSON());
        }
        if (this.binRanges && this.binRanges.constructor === Array) {
            data["BinRanges"] = [];
            for (let item of this.binRanges)
                data["BinRanges"].push(item.toJSON());
        }
        if (this.aggregateParameters && this.aggregateParameters.constructor === Array) {
            data["AggregateParameters"] = [];
            for (let item of this.aggregateParameters)
                data["AggregateParameters"].push(item.toJSON());
        }
        data["NullValueCount"] = this.nullValueCount;
        if (this.bins) {
            data["Bins"] = {};
            for (let key in this.bins) {
                if (this.bins.hasOwnProperty(key))
                    data["Bins"][key] = this.bins[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHistogramResult extends IDistResult {
    aggregateResults?: AggregateResult[][] | undefined;
    isEmpty?: boolean | undefined;
    brushes?: Brush[] | undefined;
    binRanges?: BinRange[] | undefined;
    aggregateParameters?: AggregateParameters[] | undefined;
    nullValueCount?: number | undefined;
    bins?: { [key: string]: Bin; } | undefined;
}

export abstract class AggregateResult implements IAggregateResult {
    hasResult?: boolean | undefined;
    n?: number | undefined;

    protected _discriminator: string;

    constructor(data?: IAggregateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AggregateResult";
    }

    init(data?: any) {
        if (data) {
            this.hasResult = data["HasResult"];
            this.n = data["N"];
        }
    }

    static fromJS(data: any): AggregateResult | undefined {
        if (data === null || data === undefined) {
            return undefined;
        }
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "MarginAggregateResult") {
            let result = new MarginAggregateResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DoubleValueAggregateResult") {
            let result = new DoubleValueAggregateResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PointsAggregateResult") {
            let result = new PointsAggregateResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SumEstimationAggregateResult") {
            let result = new SumEstimationAggregateResult();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AggregateResult' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["HasResult"] = this.hasResult;
        data["N"] = this.n;
        return data;
    }
}

export interface IAggregateResult {
    hasResult?: boolean | undefined;
    n?: number | undefined;
}

export class MarginAggregateResult extends AggregateResult implements IMarginAggregateResult {
    margin?: number | undefined;
    absolutMargin?: number | undefined;
    sumOfSquare?: number | undefined;
    sampleStandardDeviation?: number | undefined;
    mean?: number | undefined;
    ex?: number | undefined;
    ex2?: number | undefined;
    variance?: number | undefined;

    constructor(data?: IMarginAggregateResult) {
        super(data);
        this._discriminator = "MarginAggregateResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.margin = data["Margin"];
            this.absolutMargin = data["AbsolutMargin"];
            this.sumOfSquare = data["SumOfSquare"];
            this.sampleStandardDeviation = data["SampleStandardDeviation"];
            this.mean = data["Mean"];
            this.ex = data["Ex"];
            this.ex2 = data["Ex2"];
            this.variance = data["Variance"];
        }
    }

    static fromJS(data: any): MarginAggregateResult {
        data = typeof data === 'object' ? data : {};
        let result = new MarginAggregateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Margin"] = this.margin;
        data["AbsolutMargin"] = this.absolutMargin;
        data["SumOfSquare"] = this.sumOfSquare;
        data["SampleStandardDeviation"] = this.sampleStandardDeviation;
        data["Mean"] = this.mean;
        data["Ex"] = this.ex;
        data["Ex2"] = this.ex2;
        data["Variance"] = this.variance;
        super.toJSON(data);
        return data;
    }
}

export interface IMarginAggregateResult extends IAggregateResult {
    margin?: number | undefined;
    absolutMargin?: number | undefined;
    sumOfSquare?: number | undefined;
    sampleStandardDeviation?: number | undefined;
    mean?: number | undefined;
    ex?: number | undefined;
    ex2?: number | undefined;
    variance?: number | undefined;
}

export class DoubleValueAggregateResult extends AggregateResult implements IDoubleValueAggregateResult {
    result?: number | undefined;
    temporaryResult?: number | undefined;

    constructor(data?: IDoubleValueAggregateResult) {
        super(data);
        this._discriminator = "DoubleValueAggregateResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.result = data["Result"];
            this.temporaryResult = data["TemporaryResult"];
        }
    }

    static fromJS(data: any): DoubleValueAggregateResult {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "SumEstimationAggregateResult") {
            let result = new SumEstimationAggregateResult();
            result.init(data);
            return result;
        }
        let result = new DoubleValueAggregateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Result"] = this.result;
        data["TemporaryResult"] = this.temporaryResult;
        super.toJSON(data);
        return data;
    }
}

export interface IDoubleValueAggregateResult extends IAggregateResult {
    result?: number | undefined;
    temporaryResult?: number | undefined;
}

export class PointsAggregateResult extends AggregateResult implements IPointsAggregateResult {
    points?: Point[] | undefined;

    constructor(data?: IPointsAggregateResult) {
        super(data);
        this._discriminator = "PointsAggregateResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Points"] && data["Points"].constructor === Array) {
                this.points = [];
                for (let item of data["Points"])
                    this.points.push(Point.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PointsAggregateResult {
        data = typeof data === 'object' ? data : {};
        let result = new PointsAggregateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.points && this.points.constructor === Array) {
            data["Points"] = [];
            for (let item of this.points)
                data["Points"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPointsAggregateResult extends IAggregateResult {
    points?: Point[] | undefined;
}

export class Point implements IPoint {
    x?: number | undefined;
    y?: number | undefined;

    constructor(data?: IPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.x = data["X"];
            this.y = data["Y"];
        }
    }

    static fromJS(data: any): Point {
        data = typeof data === 'object' ? data : {};
        let result = new Point();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["X"] = this.x;
        data["Y"] = this.y;
        return data;
    }
}

export interface IPoint {
    x?: number | undefined;
    y?: number | undefined;
}

export class SumEstimationAggregateResult extends DoubleValueAggregateResult implements ISumEstimationAggregateResult {
    sum?: number | undefined;
    sumEstimation?: number | undefined;

    constructor(data?: ISumEstimationAggregateResult) {
        super(data);
        this._discriminator = "SumEstimationAggregateResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.sum = data["Sum"];
            this.sumEstimation = data["SumEstimation"];
        }
    }

    static fromJS(data: any): SumEstimationAggregateResult {
        data = typeof data === 'object' ? data : {};
        let result = new SumEstimationAggregateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Sum"] = this.sum;
        data["SumEstimation"] = this.sumEstimation;
        super.toJSON(data);
        return data;
    }
}

export interface ISumEstimationAggregateResult extends IDoubleValueAggregateResult {
    sum?: number | undefined;
    sumEstimation?: number | undefined;
}

export class Brush implements IBrush {
    brushIndex?: number | undefined;
    brushEnum?: BrushEnum | undefined;

    constructor(data?: IBrush) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brushIndex = data["BrushIndex"];
            this.brushEnum = data["BrushEnum"];
        }
    }

    static fromJS(data: any): Brush {
        data = typeof data === 'object' ? data : {};
        let result = new Brush();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BrushIndex"] = this.brushIndex;
        data["BrushEnum"] = this.brushEnum;
        return data;
    }
}

export interface IBrush {
    brushIndex?: number | undefined;
    brushEnum?: BrushEnum | undefined;
}

export enum BrushEnum {
    Overlap = 0,
    Rest = 1,
    All = 2,
    UserSpecified = 3,
}

export abstract class BinRange implements IBinRange {
    minValue?: number | undefined;
    maxValue?: number | undefined;
    targetBinNumber?: number | undefined;

    protected _discriminator: string;

    constructor(data?: IBinRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BinRange";
    }

    init(data?: any) {
        if (data) {
            this.minValue = data["MinValue"];
            this.maxValue = data["MaxValue"];
            this.targetBinNumber = data["TargetBinNumber"];
        }
    }

    static fromJS(data: any): BinRange {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "NominalBinRange") {
            let result = new NominalBinRange();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "QuantitativeBinRange") {
            let result = new QuantitativeBinRange();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AggregateBinRange") {
            let result = new AggregateBinRange();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AlphabeticBinRange") {
            let result = new AlphabeticBinRange();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DateTimeBinRange") {
            let result = new DateTimeBinRange();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'BinRange' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["MinValue"] = this.minValue;
        data["MaxValue"] = this.maxValue;
        data["TargetBinNumber"] = this.targetBinNumber;
        return data;
    }
}

export interface IBinRange {
    minValue?: number | undefined;
    maxValue?: number | undefined;
    targetBinNumber?: number | undefined;
}

export class NominalBinRange extends BinRange implements INominalBinRange {
    labelsValue?: { [key: string]: number; } | undefined;
    valuesLabel?: { [key: string]: string; } | undefined;

    constructor(data?: INominalBinRange) {
        super(data);
        this._discriminator = "NominalBinRange";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["LabelsValue"]) {
                this.labelsValue = {};
                for (let key in data["LabelsValue"]) {
                    if (data["LabelsValue"].hasOwnProperty(key))
                        this.labelsValue[key] = data["LabelsValue"][key];
                }
            }
            if (data["ValuesLabel"]) {
                this.valuesLabel = {};
                for (let key in data["ValuesLabel"]) {
                    if (data["ValuesLabel"].hasOwnProperty(key))
                        this.valuesLabel[key] = data["ValuesLabel"][key];
                }
            }
        }
    }

    static fromJS(data: any): NominalBinRange {
        data = typeof data === 'object' ? data : {};
        let result = new NominalBinRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.labelsValue) {
            data["LabelsValue"] = {};
            for (let key in this.labelsValue) {
                if (this.labelsValue.hasOwnProperty(key))
                    data["LabelsValue"][key] = this.labelsValue[key];
            }
        }
        if (this.valuesLabel) {
            data["ValuesLabel"] = {};
            for (let key in this.valuesLabel) {
                if (this.valuesLabel.hasOwnProperty(key))
                    data["ValuesLabel"][key] = this.valuesLabel[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface INominalBinRange extends IBinRange {
    labelsValue?: { [key: string]: number; } | undefined;
    valuesLabel?: { [key: string]: string; } | undefined;
}

export class QuantitativeBinRange extends BinRange implements IQuantitativeBinRange {
    isIntegerRange?: boolean | undefined;
    step?: number | undefined;

    constructor(data?: IQuantitativeBinRange) {
        super(data);
        this._discriminator = "QuantitativeBinRange";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.isIntegerRange = data["IsIntegerRange"];
            this.step = data["Step"];
        }
    }

    static fromJS(data: any): QuantitativeBinRange {
        data = typeof data === 'object' ? data : {};
        let result = new QuantitativeBinRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsIntegerRange"] = this.isIntegerRange;
        data["Step"] = this.step;
        super.toJSON(data);
        return data;
    }
}

export interface IQuantitativeBinRange extends IBinRange {
    isIntegerRange?: boolean | undefined;
    step?: number | undefined;
}

export class AggregateBinRange extends BinRange implements IAggregateBinRange {

    constructor(data?: IAggregateBinRange) {
        super(data);
        this._discriminator = "AggregateBinRange";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): AggregateBinRange {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateBinRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAggregateBinRange extends IBinRange {
}

export class AlphabeticBinRange extends BinRange implements IAlphabeticBinRange {
    prefix?: string | undefined;
    labelsValue?: { [key: string]: number; } | undefined;
    valuesLabel?: { [key: string]: string; } | undefined;

    constructor(data?: IAlphabeticBinRange) {
        super(data);
        this._discriminator = "AlphabeticBinRange";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.prefix = data["Prefix"];
            if (data["LabelsValue"]) {
                this.labelsValue = {};
                for (let key in data["LabelsValue"]) {
                    if (data["LabelsValue"].hasOwnProperty(key))
                        this.labelsValue[key] = data["LabelsValue"][key];
                }
            }
            if (data["ValuesLabel"]) {
                this.valuesLabel = {};
                for (let key in data["ValuesLabel"]) {
                    if (data["ValuesLabel"].hasOwnProperty(key))
                        this.valuesLabel[key] = data["ValuesLabel"][key];
                }
            }
        }
    }

    static fromJS(data: any): AlphabeticBinRange {
        data = typeof data === 'object' ? data : {};
        let result = new AlphabeticBinRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Prefix"] = this.prefix;
        if (this.labelsValue) {
            data["LabelsValue"] = {};
            for (let key in this.labelsValue) {
                if (this.labelsValue.hasOwnProperty(key))
                    data["LabelsValue"][key] = this.labelsValue[key];
            }
        }
        if (this.valuesLabel) {
            data["ValuesLabel"] = {};
            for (let key in this.valuesLabel) {
                if (this.valuesLabel.hasOwnProperty(key))
                    data["ValuesLabel"][key] = this.valuesLabel[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAlphabeticBinRange extends IBinRange {
    prefix?: string | undefined;
    labelsValue?: { [key: string]: number; } | undefined;
    valuesLabel?: { [key: string]: string; } | undefined;
}

export class DateTimeBinRange extends BinRange implements IDateTimeBinRange {
    step?: DateTimeStep | undefined;

    constructor(data?: IDateTimeBinRange) {
        super(data);
        this._discriminator = "DateTimeBinRange";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.step = data["Step"] ? DateTimeStep.fromJS(data["Step"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DateTimeBinRange {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeBinRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Step"] = this.step ? this.step.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDateTimeBinRange extends IBinRange {
    step?: DateTimeStep | undefined;
}

export class DateTimeStep implements IDateTimeStep {
    dateTimeStepGranularity?: DateTimeStepGranularity | undefined;
    dateTimeStepValue?: number | undefined;
    dateTimeStepMaxValue?: number | undefined;

    constructor(data?: IDateTimeStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateTimeStepGranularity = data["DateTimeStepGranularity"];
            this.dateTimeStepValue = data["DateTimeStepValue"];
            this.dateTimeStepMaxValue = data["DateTimeStepMaxValue"];
        }
    }

    static fromJS(data: any): DateTimeStep {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DateTimeStepGranularity"] = this.dateTimeStepGranularity;
        data["DateTimeStepValue"] = this.dateTimeStepValue;
        data["DateTimeStepMaxValue"] = this.dateTimeStepMaxValue;
        return data;
    }
}

export interface IDateTimeStep {
    dateTimeStepGranularity?: DateTimeStepGranularity | undefined;
    dateTimeStepValue?: number | undefined;
    dateTimeStepMaxValue?: number | undefined;
}

export enum DateTimeStepGranularity {
    Second = 0,
    Minute = 1,
    Hour = 2,
    Day = 3,
    Month = 4,
    Year = 5,
}

export class Bin implements IBin {
    aggregateResults?: AggregateResult[] | undefined;
    count?: number | undefined;
    binIndex?: BinIndex | undefined;
    spans?: Span[] | undefined;
    xSize?: number | undefined;
    ySize?: number | undefined;

    constructor(data?: IBin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["AggregateResults"] && data["AggregateResults"].constructor === Array) {
                this.aggregateResults = [];
                for (let item of data["AggregateResults"]) {
                    let fromJs = AggregateResult.fromJS(item);
                    if (fromJs)
                        this.aggregateResults.push(fromJs);
                }
            }
            this.count = data["Count"];
            this.binIndex = data["BinIndex"] ? BinIndex.fromJS(data["BinIndex"]) : <any>undefined;
            if (data["Spans"] && data["Spans"].constructor === Array) {
                this.spans = [];
                for (let item of data["Spans"])
                    this.spans.push(Span.fromJS(item));
            }
            this.xSize = data["XSize"];
            this.ySize = data["YSize"];
        }
    }

    static fromJS(data: any): Bin {
        data = typeof data === 'object' ? data : {};
        let result = new Bin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.aggregateResults && this.aggregateResults.constructor === Array) {
            data["AggregateResults"] = [];
            for (let item of this.aggregateResults)
                data["AggregateResults"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["BinIndex"] = this.binIndex ? this.binIndex.toJSON() : <any>undefined;
        if (this.spans && this.spans.constructor === Array) {
            data["Spans"] = [];
            for (let item of this.spans)
                data["Spans"].push(item.toJSON());
        }
        data["XSize"] = this.xSize;
        data["YSize"] = this.ySize;
        return data;
    }
}

export interface IBin {
    aggregateResults?: AggregateResult[] | undefined;
    count?: number | undefined;
    binIndex?: BinIndex | undefined;
    spans?: Span[] | undefined;
    xSize?: number | undefined;
    ySize?: number | undefined;
}

export class BinIndex implements IBinIndex {
    indices?: number[] | undefined;
    flatIndex?: number | undefined;

    constructor(data?: IBinIndex) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Indices"] && data["Indices"].constructor === Array) {
                this.indices = [];
                for (let item of data["Indices"])
                    this.indices.push(item);
            }
            this.flatIndex = data["FlatIndex"];
        }
    }

    static fromJS(data: any): BinIndex {
        data = typeof data === 'object' ? data : {};
        let result = new BinIndex();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.indices && this.indices.constructor === Array) {
            data["Indices"] = [];
            for (let item of this.indices)
                data["Indices"].push(item);
        }
        data["FlatIndex"] = this.flatIndex;
        return data;
    }
}

export interface IBinIndex {
    indices?: number[] | undefined;
    flatIndex?: number | undefined;
}

export class Span implements ISpan {
    min?: number | undefined;
    max?: number | undefined;
    index?: number | undefined;

    constructor(data?: ISpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.min = data["Min"];
            this.max = data["Max"];
            this.index = data["Index"];
        }
    }

    static fromJS(data: any): Span {
        data = typeof data === 'object' ? data : {};
        let result = new Span();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Min"] = this.min;
        data["Max"] = this.max;
        data["Index"] = this.index;
        return data;
    }
}

export interface ISpan {
    min?: number | undefined;
    max?: number | undefined;
    index?: number | undefined;
}

export class ModelWealthResult extends Result implements IModelWealthResult {
    wealth?: number | undefined;
    startWealth?: number | undefined;

    constructor(data?: IModelWealthResult) {
        super(data);
        this._discriminator = "ModelWealthResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.wealth = data["Wealth"];
            this.startWealth = data["StartWealth"];
        }
    }

    static fromJS(data: any): ModelWealthResult {
        data = typeof data === 'object' ? data : {};
        let result = new ModelWealthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Wealth"] = this.wealth;
        data["StartWealth"] = this.startWealth;
        super.toJSON(data);
        return data;
    }
}

export interface IModelWealthResult extends IResult {
    wealth?: number | undefined;
    startWealth?: number | undefined;
}

export abstract class HypothesisTestResult extends Result implements IHypothesisTestResult {
    pValue?: number | undefined;
    statistic?: number | undefined;
    support?: number | undefined;
    sampleSizes?: number[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IHypothesisTestResult) {
        super(data);
        this._discriminator = "HypothesisTestResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pValue = data["PValue"];
            this.statistic = data["Statistic"];
            this.support = data["Support"];
            if (data["SampleSizes"] && data["SampleSizes"].constructor === Array) {
                this.sampleSizes = [];
                for (let item of data["SampleSizes"])
                    this.sampleSizes.push(item);
            }
            this.errorMessage = data["ErrorMessage"];
        }
    }

    static fromJS(data: any): HypothesisTestResult {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "ChiSquaredTestResult") {
            let result = new ChiSquaredTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CorrelationTestResult") {
            let result = new CorrelationTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "KSTestResult") {
            let result = new KSTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "RootMeanSquareTestResult") {
            let result = new RootMeanSquareTestResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TTestResult") {
            let result = new TTestResult();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'HypothesisTestResult' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PValue"] = this.pValue;
        data["Statistic"] = this.statistic;
        data["Support"] = this.support;
        if (this.sampleSizes && this.sampleSizes.constructor === Array) {
            data["SampleSizes"] = [];
            for (let item of this.sampleSizes)
                data["SampleSizes"].push(item);
        }
        data["ErrorMessage"] = this.errorMessage;
        super.toJSON(data);
        return data;
    }
}

export interface IHypothesisTestResult extends IResult {
    pValue?: number | undefined;
    statistic?: number | undefined;
    support?: number | undefined;
    sampleSizes?: number[] | undefined;
    errorMessage?: string | undefined;
}

export abstract class ModelOperationResult extends Result implements IModelOperationResult {
    modelId?: ModelId | undefined;

    constructor(data?: IModelOperationResult) {
        super(data);
        this._discriminator = "ModelOperationResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.modelId = data["ModelId"] ? ModelId.fromJS(data["ModelId"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelOperationResult {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "NewModelOperationResult") {
            let result = new NewModelOperationResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "AddComparisonResult") {
            let result = new AddComparisonResult();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "GetModelStateResult") {
            let result = new GetModelStateResult();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'ModelOperationResult' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ModelId"] = this.modelId ? this.modelId.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IModelOperationResult extends IResult {
    modelId?: ModelId | undefined;
}

export class RecommenderResult extends Result implements IRecommenderResult {
    recommendedHistograms?: RecommendedHistogram[] | undefined;
    totalCount?: number | undefined;

    constructor(data?: IRecommenderResult) {
        super(data);
        this._discriminator = "RecommenderResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["RecommendedHistograms"] && data["RecommendedHistograms"].constructor === Array) {
                this.recommendedHistograms = [];
                for (let item of data["RecommendedHistograms"])
                    this.recommendedHistograms.push(RecommendedHistogram.fromJS(item));
            }
            this.totalCount = data["TotalCount"];
        }
    }

    static fromJS(data: any): RecommenderResult {
        data = typeof data === 'object' ? data : {};
        let result = new RecommenderResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.recommendedHistograms && this.recommendedHistograms.constructor === Array) {
            data["RecommendedHistograms"] = [];
            for (let item of this.recommendedHistograms)
                data["RecommendedHistograms"].push(item.toJSON());
        }
        data["TotalCount"] = this.totalCount;
        super.toJSON(data);
        return data;
    }
}

export interface IRecommenderResult extends IResult {
    recommendedHistograms?: RecommendedHistogram[] | undefined;
    totalCount?: number | undefined;
}

export class RecommendedHistogram implements IRecommendedHistogram {
    histogramResult?: HistogramResult | undefined;
    selectedBinIndices?: BinIndex[] | undefined;
    selections?: Selection[] | undefined;
    pValue?: number | undefined;
    significance?: boolean | undefined;
    decision?: Decision | undefined;
    effectSize?: number | undefined;
    hypothesisTestResult?: HypothesisTestResult | undefined;
    id?: string | undefined;
    xAttribute?: Attribute | undefined;
    yAttribute?: Attribute | undefined;

    constructor(data?: IRecommendedHistogram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.histogramResult = data["HistogramResult"] ? HistogramResult.fromJS(data["HistogramResult"]) : <any>undefined;
            if (data["SelectedBinIndices"] && data["SelectedBinIndices"].constructor === Array) {
                this.selectedBinIndices = [];
                for (let item of data["SelectedBinIndices"])
                    this.selectedBinIndices.push(BinIndex.fromJS(item));
            }
            if (data["Selections"] && data["Selections"].constructor === Array) {
                this.selections = [];
                for (let item of data["Selections"])
                    this.selections.push(Selection.fromJS(item));
            }
            this.pValue = data["PValue"];
            this.significance = data["Significance"];
            this.decision = data["Decision"] ? Decision.fromJS(data["Decision"]) : <any>undefined;
            this.effectSize = data["EffectSize"];
            this.hypothesisTestResult = data["HypothesisTestResult"] ? HypothesisTestResult.fromJS(data["HypothesisTestResult"]) : <any>undefined;
            this.id = data["Id"];
            this.xAttribute = data["XAttribute"] ? Attribute.fromJS(data["XAttribute"]) : <any>undefined;
            this.yAttribute = data["YAttribute"] ? Attribute.fromJS(data["YAttribute"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecommendedHistogram {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendedHistogram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HistogramResult"] = this.histogramResult ? this.histogramResult.toJSON() : <any>undefined;
        if (this.selectedBinIndices && this.selectedBinIndices.constructor === Array) {
            data["SelectedBinIndices"] = [];
            for (let item of this.selectedBinIndices)
                data["SelectedBinIndices"].push(item.toJSON());
        }
        if (this.selections && this.selections.constructor === Array) {
            data["Selections"] = [];
            for (let item of this.selections)
                data["Selections"].push(item.toJSON());
        }
        data["PValue"] = this.pValue;
        data["Significance"] = this.significance;
        data["Decision"] = this.decision ? this.decision.toJSON() : <any>undefined;
        data["EffectSize"] = this.effectSize;
        data["HypothesisTestResult"] = this.hypothesisTestResult ? this.hypothesisTestResult.toJSON() : <any>undefined;
        data["Id"] = this.id;
        data["XAttribute"] = this.xAttribute ? this.xAttribute.toJSON() : <any>undefined;
        data["YAttribute"] = this.yAttribute ? this.yAttribute.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRecommendedHistogram {
    histogramResult?: HistogramResult | undefined;
    selectedBinIndices?: BinIndex[] | undefined;
    selections?: Selection[] | undefined;
    pValue?: number | undefined;
    significance?: boolean | undefined;
    decision?: Decision | undefined;
    effectSize?: number | undefined;
    hypothesisTestResult?: HypothesisTestResult | undefined;
    id?: string | undefined;
    xAttribute?: Attribute | undefined;
    yAttribute?: Attribute | undefined;
}

export class Selection implements ISelection {
    statements?: Statement[] | undefined;
    filterHistogramOperationReference?: IOperationReference | undefined;

    constructor(data?: ISelection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Statements"] && data["Statements"].constructor === Array) {
                this.statements = [];
                for (let item of data["Statements"])
                    this.statements.push(Statement.fromJS(item));
            }
            this.filterHistogramOperationReference = data["FilterHistogramOperationReference"] ? IOperationReference.fromJS(data["FilterHistogramOperationReference"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Selection {
        data = typeof data === 'object' ? data : {};
        let result = new Selection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.statements && this.statements.constructor === Array) {
            data["Statements"] = [];
            for (let item of this.statements)
                data["Statements"].push(item.toJSON());
        }
        data["FilterHistogramOperationReference"] = this.filterHistogramOperationReference ? this.filterHistogramOperationReference.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelection {
    statements?: Statement[] | undefined;
    filterHistogramOperationReference?: IOperationReference | undefined;
}

export class Statement implements IStatement {
    attribute?: Attribute | undefined;
    predicate?: Predicate | undefined;
    value?: any | undefined;

    constructor(data?: IStatement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attribute = data["Attribute"] ? Attribute.fromJS(data["Attribute"]) : <any>undefined;
            this.predicate = data["Predicate"];
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): Statement {
        data = typeof data === 'object' ? data : {};
        let result = new Statement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Attribute"] = this.attribute ? this.attribute.toJSON() : <any>undefined;
        data["Predicate"] = this.predicate;
        data["Value"] = this.value;
        return data;
    }
}

export interface IStatement {
    attribute?: Attribute | undefined;
    predicate?: Predicate | undefined;
    value?: any | undefined;
}

export enum Predicate {
    EQUALS = 0,
    LIKE = 1,
    GREATER_THAN = 2,
    LESS_THAN = 3,
    GREATER_THAN_EQUAL = 4,
    LESS_THAN_EQUAL = 5,
    STARTS_WITH = 6,
    ENDS_WITH = 7,
    CONTAINS = 8,
}

export abstract class IOperationReference implements IIOperationReference {
    id?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IIOperationReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "IOperationReference";
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): IOperationReference {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "OperationReference") {
            let result = new OperationReference();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'IOperationReference' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["Id"] = this.id;
        return data;
    }
}

export interface IIOperationReference {
    id?: string | undefined;
}

export class OperationReference extends IOperationReference implements IOperationReference {
    id?: string | undefined;

    constructor(data?: IOperationReference) {
        super(data);
        this._discriminator = "OperationReference";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): OperationReference {
        data = typeof data === 'object' ? data : {};
        let result = new OperationReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IOperationReference extends IIOperationReference {
    id?: string | undefined;
}

export class Decision extends Result implements IDecision {
    comparisonId?: ComparisonId | undefined;
    riskControlType?: RiskControlType | undefined;
    significance?: boolean | undefined;
    pValue?: number | undefined;
    lhs?: number | undefined;
    significanceLevel?: number | undefined;
    sampleSizeEstimate?: number | undefined;

    constructor(data?: IDecision) {
        super(data);
        this._discriminator = "Decision";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.comparisonId = data["ComparisonId"] ? ComparisonId.fromJS(data["ComparisonId"]) : <any>undefined;
            this.riskControlType = data["RiskControlType"];
            this.significance = data["Significance"];
            this.pValue = data["PValue"];
            this.lhs = data["Lhs"];
            this.significanceLevel = data["SignificanceLevel"];
            this.sampleSizeEstimate = data["SampleSizeEstimate"];
        }
    }

    static fromJS(data: any): Decision {
        data = typeof data === 'object' ? data : {};
        let result = new Decision();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ComparisonId"] = this.comparisonId ? this.comparisonId.toJSON() : <any>undefined;
        data["RiskControlType"] = this.riskControlType;
        data["Significance"] = this.significance;
        data["PValue"] = this.pValue;
        data["Lhs"] = this.lhs;
        data["SignificanceLevel"] = this.significanceLevel;
        data["SampleSizeEstimate"] = this.sampleSizeEstimate;
        super.toJSON(data);
        return data;
    }
}

export interface IDecision extends IResult {
    comparisonId?: ComparisonId | undefined;
    riskControlType?: RiskControlType | undefined;
    significance?: boolean | undefined;
    pValue?: number | undefined;
    lhs?: number | undefined;
    significanceLevel?: number | undefined;
    sampleSizeEstimate?: number | undefined;
}

export class ComparisonId implements IComparisonId {
    value?: string | undefined;

    constructor(data?: IComparisonId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): ComparisonId {
        data = typeof data === 'object' ? data : {};
        let result = new ComparisonId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        return data;
    }
}

export interface IComparisonId {
    value?: string | undefined;
}

export class OptimizerResult extends Result implements IOptimizerResult {
    topKSolutions?: Solution[] | undefined;

    constructor(data?: IOptimizerResult) {
        super(data);
        this._discriminator = "OptimizerResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["TopKSolutions"] && data["TopKSolutions"].constructor === Array) {
                this.topKSolutions = [];
                for (let item of data["TopKSolutions"])
                    this.topKSolutions.push(Solution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OptimizerResult {
        data = typeof data === 'object' ? data : {};
        let result = new OptimizerResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.topKSolutions && this.topKSolutions.constructor === Array) {
            data["TopKSolutions"] = [];
            for (let item of this.topKSolutions)
                data["TopKSolutions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOptimizerResult extends IResult {
    topKSolutions?: Solution[] | undefined;
}

export class Solution implements ISolution {
    solutionId?: string | undefined;
    stepDescriptions?: StepDescription[] | undefined;
    pipelineDescription?: PipelineDescription | undefined;
    score?: Score | undefined;
    naiveScore?: Score | undefined;

    constructor(data?: ISolution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.solutionId = data["SolutionId"];
            if (data["StepDescriptions"] && data["StepDescriptions"].constructor === Array) {
                this.stepDescriptions = [];
                for (let item of data["StepDescriptions"])
                    this.stepDescriptions.push(StepDescription.fromJS(item));
            }
            this.pipelineDescription = data["PipelineDescription"] ? PipelineDescription.fromJS(data["PipelineDescription"]) : <any>undefined;
            this.score = data["Score"] ? Score.fromJS(data["Score"]) : <any>undefined;
            this.naiveScore = data["NaiveScore"] ? Score.fromJS(data["NaiveScore"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Solution {
        data = typeof data === 'object' ? data : {};
        let result = new Solution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SolutionId"] = this.solutionId;
        if (this.stepDescriptions && this.stepDescriptions.constructor === Array) {
            data["StepDescriptions"] = [];
            for (let item of this.stepDescriptions)
                data["StepDescriptions"].push(item.toJSON());
        }
        data["PipelineDescription"] = this.pipelineDescription ? this.pipelineDescription.toJSON() : <any>undefined;
        data["Score"] = this.score ? this.score.toJSON() : <any>undefined;
        data["NaiveScore"] = this.naiveScore ? this.naiveScore.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISolution {
    solutionId?: string | undefined;
    stepDescriptions?: StepDescription[] | undefined;
    pipelineDescription?: PipelineDescription | undefined;
    score?: Score | undefined;
    naiveScore?: Score | undefined;
}

export class StepDescription implements IStepDescription {

    protected _discriminator: string;

    constructor(data?: IStepDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "StepDescription";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): StepDescription {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "SubpipelineStepDescription") {
            let result = new SubpipelineStepDescription();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PrimitiveStepDescription") {
            let result = new PrimitiveStepDescription();
            result.init(data);
            return result;
        }
        let result = new StepDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        return data;
    }
}

export interface IStepDescription {
}

export class SubpipelineStepDescription extends StepDescription implements ISubpipelineStepDescription {
    steps?: StepDescription[] | undefined;

    constructor(data?: ISubpipelineStepDescription) {
        super(data);
        this._discriminator = "SubpipelineStepDescription";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Steps"] && data["Steps"].constructor === Array) {
                this.steps = [];
                for (let item of data["Steps"])
                    this.steps.push(StepDescription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubpipelineStepDescription {
        data = typeof data === 'object' ? data : {};
        let result = new SubpipelineStepDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.steps && this.steps.constructor === Array) {
            data["Steps"] = [];
            for (let item of this.steps)
                data["Steps"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISubpipelineStepDescription extends IStepDescription {
    steps?: StepDescription[] | undefined;
}

export class PipelineDescription implements IPipelineDescription {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    inputs?: PipelineDescriptionInput[] | undefined;
    outputs?: PipelineDescriptionOutput[] | undefined;
    steps?: PipelineDescriptionStep[] | undefined;

    constructor(data?: IPipelineDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.name = data["Name"];
            this.description = data["Description"];
            if (data["Inputs"] && data["Inputs"].constructor === Array) {
                this.inputs = [];
                for (let item of data["Inputs"])
                    this.inputs.push(PipelineDescriptionInput.fromJS(item));
            }
            if (data["Outputs"] && data["Outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["Outputs"])
                    this.outputs.push(PipelineDescriptionOutput.fromJS(item));
            }
            if (data["Steps"] && data["Steps"].constructor === Array) {
                this.steps = [];
                for (let item of data["Steps"])
                    this.steps.push(PipelineDescriptionStep.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PipelineDescription {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (this.inputs && this.inputs.constructor === Array) {
            data["Inputs"] = [];
            for (let item of this.inputs)
                data["Inputs"].push(item.toJSON());
        }
        if (this.outputs && this.outputs.constructor === Array) {
            data["Outputs"] = [];
            for (let item of this.outputs)
                data["Outputs"].push(item.toJSON());
        }
        if (this.steps && this.steps.constructor === Array) {
            data["Steps"] = [];
            for (let item of this.steps)
                data["Steps"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPipelineDescription {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    inputs?: PipelineDescriptionInput[] | undefined;
    outputs?: PipelineDescriptionOutput[] | undefined;
    steps?: PipelineDescriptionStep[] | undefined;
}

export class PipelineDescriptionInput implements IPipelineDescriptionInput {
    name?: string | undefined;

    constructor(data?: IPipelineDescriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): PipelineDescriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineDescriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        return data;
    }
}

export interface IPipelineDescriptionInput {
    name?: string | undefined;
}

export class PipelineDescriptionOutput implements IPipelineDescriptionOutput {
    name?: string | undefined;
    data?: string | undefined;

    constructor(data?: IPipelineDescriptionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.data = data["Data"];
        }
    }

    static fromJS(data: any): PipelineDescriptionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PipelineDescriptionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Data"] = this.data;
        return data;
    }
}

export interface IPipelineDescriptionOutput {
    name?: string | undefined;
    data?: string | undefined;
}

export class PipelineDescriptionStep implements IPipelineDescriptionStep {
    outputs?: StepOutput[] | undefined;

    protected _discriminator: string;

    constructor(data?: IPipelineDescriptionStep) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PipelineDescriptionStep";
    }

    init(data?: any) {
        if (data) {
            if (data["Outputs"] && data["Outputs"].constructor === Array) {
                this.outputs = [];
                for (let item of data["Outputs"])
                    this.outputs.push(StepOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PipelineDescriptionStep {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "PlaceholderPipelineDescriptionStep") {
            let result = new PlaceholderPipelineDescriptionStep();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "SubpipelinePipelineDescriptionStep") {
            let result = new SubpipelinePipelineDescriptionStep();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PrimitivePipelineDescriptionStep") {
            let result = new PrimitivePipelineDescriptionStep();
            result.init(data);
            return result;
        }
        let result = new PipelineDescriptionStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        if (this.outputs && this.outputs.constructor === Array) {
            data["Outputs"] = [];
            for (let item of this.outputs)
                data["Outputs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPipelineDescriptionStep {
    outputs?: StepOutput[] | undefined;
}

export class StepOutput implements IStepOutput {
    id?: string | undefined;

    constructor(data?: IStepOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
        }
    }

    static fromJS(data: any): StepOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StepOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        return data;
    }
}

export interface IStepOutput {
    id?: string | undefined;
}

export class PlaceholderPipelineDescriptionStep extends PipelineDescriptionStep implements IPlaceholderPipelineDescriptionStep {
    inputs?: StepInput[] | undefined;

    constructor(data?: IPlaceholderPipelineDescriptionStep) {
        super(data);
        this._discriminator = "PlaceholderPipelineDescriptionStep";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Inputs"] && data["Inputs"].constructor === Array) {
                this.inputs = [];
                for (let item of data["Inputs"])
                    this.inputs.push(StepInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlaceholderPipelineDescriptionStep {
        data = typeof data === 'object' ? data : {};
        let result = new PlaceholderPipelineDescriptionStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.inputs && this.inputs.constructor === Array) {
            data["Inputs"] = [];
            for (let item of this.inputs)
                data["Inputs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPlaceholderPipelineDescriptionStep extends IPipelineDescriptionStep {
    inputs?: StepInput[] | undefined;
}

export class StepInput implements IStepInput {
    data?: string | undefined;

    constructor(data?: IStepInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["Data"];
        }
    }

    static fromJS(data: any): StepInput {
        data = typeof data === 'object' ? data : {};
        let result = new StepInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        return data;
    }
}

export interface IStepInput {
    data?: string | undefined;
}

export class SubpipelinePipelineDescriptionStep extends PipelineDescriptionStep implements ISubpipelinePipelineDescriptionStep {
    pipelineDescription?: PipelineDescription | undefined;
    inputs?: StepInput[] | undefined;

    constructor(data?: ISubpipelinePipelineDescriptionStep) {
        super(data);
        this._discriminator = "SubpipelinePipelineDescriptionStep";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pipelineDescription = data["PipelineDescription"] ? PipelineDescription.fromJS(data["PipelineDescription"]) : <any>undefined;
            if (data["Inputs"] && data["Inputs"].constructor === Array) {
                this.inputs = [];
                for (let item of data["Inputs"])
                    this.inputs.push(StepInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubpipelinePipelineDescriptionStep {
        data = typeof data === 'object' ? data : {};
        let result = new SubpipelinePipelineDescriptionStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PipelineDescription"] = this.pipelineDescription ? this.pipelineDescription.toJSON() : <any>undefined;
        if (this.inputs && this.inputs.constructor === Array) {
            data["Inputs"] = [];
            for (let item of this.inputs)
                data["Inputs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISubpipelinePipelineDescriptionStep extends IPipelineDescriptionStep {
    pipelineDescription?: PipelineDescription | undefined;
    inputs?: StepInput[] | undefined;
}

export class PrimitivePipelineDescriptionStep extends PipelineDescriptionStep implements IPrimitivePipelineDescriptionStep {
    primitive?: Primitive | undefined;
    arguments?: { [key: string]: PrimitiveStepArgument; } | undefined;
    hyperparams?: { [key: string]: PrimitiveStepHyperparameter; } | undefined;

    constructor(data?: IPrimitivePipelineDescriptionStep) {
        super(data);
        this._discriminator = "PrimitivePipelineDescriptionStep";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.primitive = data["Primitive"] ? Primitive.fromJS(data["Primitive"]) : <any>undefined;
            if (data["Arguments"]) {
                this.arguments = {};
                for (let key in data["Arguments"]) {
                    if (data["Arguments"].hasOwnProperty(key))
                        this.arguments[key] = data["Arguments"][key] ? PrimitiveStepArgument.fromJS(data["Arguments"][key]) : new PrimitiveStepArgument();
                }
            }
            if (data["Hyperparams"]) {
                this.hyperparams = {};
                for (let key in data["Hyperparams"]) {
                    if (data["Hyperparams"].hasOwnProperty(key))
                        this.hyperparams[key] = data["Hyperparams"][key] ? PrimitiveStepHyperparameter.fromJS(data["Hyperparams"][key]) : new PrimitiveStepHyperparameter();
                }
            }
        }
    }

    static fromJS(data: any): PrimitivePipelineDescriptionStep {
        data = typeof data === 'object' ? data : {};
        let result = new PrimitivePipelineDescriptionStep();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Primitive"] = this.primitive ? this.primitive.toJSON() : <any>undefined;
        if (this.arguments) {
            data["Arguments"] = {};
            for (let key in this.arguments) {
                if (this.arguments.hasOwnProperty(key))
                    data["Arguments"][key] = this.arguments[key];
            }
        }
        if (this.hyperparams) {
            data["Hyperparams"] = {};
            for (let key in this.hyperparams) {
                if (this.hyperparams.hasOwnProperty(key))
                    data["Hyperparams"][key] = this.hyperparams[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPrimitivePipelineDescriptionStep extends IPipelineDescriptionStep {
    primitive?: Primitive | undefined;
    arguments?: { [key: string]: PrimitiveStepArgument; } | undefined;
    hyperparams?: { [key: string]: PrimitiveStepHyperparameter; } | undefined;
}

export class Primitive implements IPrimitive {
    id?: string | undefined;
    version?: string | undefined;
    pythonPath?: string | undefined;
    name?: string | undefined;
    digest?: string | undefined;

    constructor(data?: IPrimitive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            this.version = data["Version"];
            this.pythonPath = data["PythonPath"];
            this.name = data["Name"];
            this.digest = data["Digest"];
        }
    }

    static fromJS(data: any): Primitive {
        data = typeof data === 'object' ? data : {};
        let result = new Primitive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Version"] = this.version;
        data["PythonPath"] = this.pythonPath;
        data["Name"] = this.name;
        data["Digest"] = this.digest;
        return data;
    }
}

export interface IPrimitive {
    id?: string | undefined;
    version?: string | undefined;
    pythonPath?: string | undefined;
    name?: string | undefined;
    digest?: string | undefined;
}

export class PrimitiveStepHyperparameter implements IPrimitiveStepHyperparameter {

    protected _discriminator: string;

    constructor(data?: IPrimitiveStepHyperparameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PrimitiveStepHyperparameter";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): PrimitiveStepHyperparameter {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "PrimitiveStepArgument") {
            let result = new PrimitiveStepArgument();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DataArguments") {
            let result = new DataArguments();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PrimitiveArgument") {
            let result = new PrimitiveArgument();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PrimitiveArguments") {
            let result = new PrimitiveArguments();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ValueArgument") {
            let result = new ValueArgument();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ContainerArgument") {
            let result = new ContainerArgument();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DataArgument") {
            let result = new DataArgument();
            result.init(data);
            return result;
        }
        let result = new PrimitiveStepHyperparameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        return data;
    }
}

export interface IPrimitiveStepHyperparameter {
}

export class PrimitiveStepArgument extends PrimitiveStepHyperparameter implements IPrimitiveStepArgument {

    protected _discriminator: string;

    constructor(data?: IPrimitiveStepArgument) {
        super(data);
        this._discriminator = "PrimitiveStepArgument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): PrimitiveStepArgument {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "ContainerArgument") {
            let result = new ContainerArgument();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DataArgument") {
            let result = new DataArgument();
            result.init(data);
            return result;
        }
        let result = new PrimitiveStepArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        super.toJSON(data);
        return data;
    }
}

export interface IPrimitiveStepArgument extends IPrimitiveStepHyperparameter {
}

export class DataArguments extends PrimitiveStepHyperparameter implements IDataArguments {
    data?: string[] | undefined;

    constructor(data?: IDataArguments) {
        super(data);
        this._discriminator = "DataArguments";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [];
                for (let item of data["Data"])
                    this.data.push(item);
            }
        }
    }

    static fromJS(data: any): DataArguments {
        data = typeof data === 'object' ? data : {};
        let result = new DataArguments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDataArguments extends IPrimitiveStepHyperparameter {
    data?: string[] | undefined;
}

export class PrimitiveArgument extends PrimitiveStepHyperparameter implements IPrimitiveArgument {
    data?: number | undefined;

    constructor(data?: IPrimitiveArgument) {
        super(data);
        this._discriminator = "PrimitiveArgument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["Data"];
        }
    }

    static fromJS(data: any): PrimitiveArgument {
        data = typeof data === 'object' ? data : {};
        let result = new PrimitiveArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        super.toJSON(data);
        return data;
    }
}

export interface IPrimitiveArgument extends IPrimitiveStepHyperparameter {
    data?: number | undefined;
}

export class PrimitiveArguments extends PrimitiveStepHyperparameter implements IPrimitiveArguments {
    data?: number[] | undefined;

    constructor(data?: IPrimitiveArguments) {
        super(data);
        this._discriminator = "PrimitiveArguments";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [];
                for (let item of data["Data"])
                    this.data.push(item);
            }
        }
    }

    static fromJS(data: any): PrimitiveArguments {
        data = typeof data === 'object' ? data : {};
        let result = new PrimitiveArguments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPrimitiveArguments extends IPrimitiveStepHyperparameter {
    data?: number[] | undefined;
}

export class ValueArgument extends PrimitiveStepHyperparameter implements IValueArgument {
    data?: Value | undefined;

    constructor(data?: IValueArgument) {
        super(data);
        this._discriminator = "ValueArgument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["Data"] ? Value.fromJS(data["Data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValueArgument {
        data = typeof data === 'object' ? data : {};
        let result = new ValueArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IValueArgument extends IPrimitiveStepHyperparameter {
    data?: Value | undefined;
}

export abstract class Value implements IValue {

    protected _discriminator: string;

    constructor(data?: IValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Value";
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Value {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "ErrorValue") {
            let result = new ErrorValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DoubleValue") {
            let result = new DoubleValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "LongValue") {
            let result = new LongValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "BoolValue") {
            let result = new BoolValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "StringValue") {
            let result = new StringValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DatasetUriValue") {
            let result = new DatasetUriValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "CsvUriValue") {
            let result = new CsvUriValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PickleUriValue") {
            let result = new PickleUriValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PickleBlobValue") {
            let result = new PickleBlobValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PlasmaIdValue") {
            let result = new PlasmaIdValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "BytesValue") {
            let result = new BytesValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ListValue") {
            let result = new ListValue();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Value' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        return data;
    }
}

export interface IValue {
}

export class ErrorValue extends Value implements IErrorValue {
    message?: string | undefined;

    constructor(data?: IErrorValue) {
        super(data);
        this._discriminator = "ErrorValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): ErrorValue {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        super.toJSON(data);
        return data;
    }
}

export interface IErrorValue extends IValue {
    message?: string | undefined;
}

export class DoubleValue extends Value implements IDoubleValue {
    value?: number | undefined;

    constructor(data?: IDoubleValue) {
        super(data);
        this._discriminator = "DoubleValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): DoubleValue {
        data = typeof data === 'object' ? data : {};
        let result = new DoubleValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IDoubleValue extends IValue {
    value?: number | undefined;
}

export class LongValue extends Value implements ILongValue {
    value?: number | undefined;

    constructor(data?: ILongValue) {
        super(data);
        this._discriminator = "LongValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): LongValue {
        data = typeof data === 'object' ? data : {};
        let result = new LongValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ILongValue extends IValue {
    value?: number | undefined;
}

export class BoolValue extends Value implements IBoolValue {
    value?: boolean | undefined;

    constructor(data?: IBoolValue) {
        super(data);
        this._discriminator = "BoolValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): BoolValue {
        data = typeof data === 'object' ? data : {};
        let result = new BoolValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IBoolValue extends IValue {
    value?: boolean | undefined;
}

export class StringValue extends Value implements IStringValue {
    value?: string | undefined;

    constructor(data?: IStringValue) {
        super(data);
        this._discriminator = "StringValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): StringValue {
        data = typeof data === 'object' ? data : {};
        let result = new StringValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IStringValue extends IValue {
    value?: string | undefined;
}

export class DatasetUriValue extends Value implements IDatasetUriValue {
    value?: string | undefined;

    constructor(data?: IDatasetUriValue) {
        super(data);
        this._discriminator = "DatasetUriValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): DatasetUriValue {
        data = typeof data === 'object' ? data : {};
        let result = new DatasetUriValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IDatasetUriValue extends IValue {
    value?: string | undefined;
}

export class CsvUriValue extends Value implements ICsvUriValue {
    value?: string | undefined;

    constructor(data?: ICsvUriValue) {
        super(data);
        this._discriminator = "CsvUriValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): CsvUriValue {
        data = typeof data === 'object' ? data : {};
        let result = new CsvUriValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface ICsvUriValue extends IValue {
    value?: string | undefined;
}

export class PickleUriValue extends Value implements IPickleUriValue {
    value?: string | undefined;

    constructor(data?: IPickleUriValue) {
        super(data);
        this._discriminator = "PickleUriValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): PickleUriValue {
        data = typeof data === 'object' ? data : {};
        let result = new PickleUriValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IPickleUriValue extends IValue {
    value?: string | undefined;
}

export class PickleBlobValue extends Value implements IPickleBlobValue {
    value?: string | undefined;

    constructor(data?: IPickleBlobValue) {
        super(data);
        this._discriminator = "PickleBlobValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): PickleBlobValue {
        data = typeof data === 'object' ? data : {};
        let result = new PickleBlobValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IPickleBlobValue extends IValue {
    value?: string | undefined;
}

export class PlasmaIdValue extends Value implements IPlasmaIdValue {
    value?: string | undefined;

    constructor(data?: IPlasmaIdValue) {
        super(data);
        this._discriminator = "PlasmaIdValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): PlasmaIdValue {
        data = typeof data === 'object' ? data : {};
        let result = new PlasmaIdValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IPlasmaIdValue extends IValue {
    value?: string | undefined;
}

export class BytesValue extends Value implements IBytesValue {
    value?: string | undefined;

    constructor(data?: IBytesValue) {
        super(data);
        this._discriminator = "BytesValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): BytesValue {
        data = typeof data === 'object' ? data : {};
        let result = new BytesValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IBytesValue extends IValue {
    value?: string | undefined;
}

export class ContainerArgument extends PrimitiveStepArgument implements IContainerArgument {
    data?: string | undefined;

    constructor(data?: IContainerArgument) {
        super(data);
        this._discriminator = "ContainerArgument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["Data"];
        }
    }

    static fromJS(data: any): ContainerArgument {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        super.toJSON(data);
        return data;
    }
}

export interface IContainerArgument extends IPrimitiveStepArgument {
    data?: string | undefined;
}

export class Score implements IScore {
    metricType?: MetricType | undefined;
    value?: number | undefined;

    constructor(data?: IScore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.metricType = data["MetricType"];
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): Score {
        data = typeof data === 'object' ? data : {};
        let result = new Score();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MetricType"] = this.metricType;
        data["Value"] = this.value;
        return data;
    }
}

export interface IScore {
    metricType?: MetricType | undefined;
    value?: number | undefined;
}

export class ExampleResult extends Result implements IExampleResult {
    resultValues?: { [key: string]: string; } | undefined;
    message?: string | undefined;

    constructor(data?: IExampleResult) {
        super(data);
        this._discriminator = "ExampleResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["ResultValues"]) {
                this.resultValues = {};
                for (let key in data["ResultValues"]) {
                    if (data["ResultValues"].hasOwnProperty(key))
                        this.resultValues[key] = data["ResultValues"][key];
                }
            }
            this.message = data["Message"];
        }
    }

    static fromJS(data: any): ExampleResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExampleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.resultValues) {
            data["ResultValues"] = {};
            for (let key in this.resultValues) {
                if (this.resultValues.hasOwnProperty(key))
                    data["ResultValues"][key] = this.resultValues[key];
            }
        }
        data["Message"] = this.message;
        super.toJSON(data);
        return data;
    }
}

export interface IExampleResult extends IResult {
    resultValues?: { [key: string]: string; } | undefined;
    message?: string | undefined;
}

export class NewModelOperationResult extends ModelOperationResult implements INewModelOperationResult {

    constructor(data?: INewModelOperationResult) {
        super(data);
        this._discriminator = "NewModelOperationResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): NewModelOperationResult {
        data = typeof data === 'object' ? data : {};
        let result = new NewModelOperationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INewModelOperationResult extends IModelOperationResult {
}

export class AddComparisonResult extends ModelOperationResult implements IAddComparisonResult {
    comparisonId?: ComparisonId | undefined;

    constructor(data?: IAddComparisonResult) {
        super(data);
        this._discriminator = "AddComparisonResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.comparisonId = data["ComparisonId"] ? ComparisonId.fromJS(data["ComparisonId"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddComparisonResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddComparisonResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ComparisonId"] = this.comparisonId ? this.comparisonId.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAddComparisonResult extends IModelOperationResult {
    comparisonId?: ComparisonId | undefined;
}

export class GetModelStateResult extends ModelOperationResult implements IGetModelStateResult {
    decisions?: Decision[] | undefined;
    startingWealth?: number | undefined;
    currentWealth?: number | undefined;

    constructor(data?: IGetModelStateResult) {
        super(data);
        this._discriminator = "GetModelStateResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Decisions"] && data["Decisions"].constructor === Array) {
                this.decisions = [];
                for (let item of data["Decisions"])
                    this.decisions.push(Decision.fromJS(item));
            }
            this.startingWealth = data["StartingWealth"];
            this.currentWealth = data["CurrentWealth"];
        }
    }

    static fromJS(data: any): GetModelStateResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelStateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.decisions && this.decisions.constructor === Array) {
            data["Decisions"] = [];
            for (let item of this.decisions)
                data["Decisions"].push(item.toJSON());
        }
        data["StartingWealth"] = this.startingWealth;
        data["CurrentWealth"] = this.currentWealth;
        super.toJSON(data);
        return data;
    }
}

export interface IGetModelStateResult extends IModelOperationResult {
    decisions?: Decision[] | undefined;
    startingWealth?: number | undefined;
    currentWealth?: number | undefined;
}

export class AggregateKey implements IAggregateKey {
    aggregateParameterIndex?: number | undefined;
    brushIndex?: number | undefined;

    constructor(data?: IAggregateKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.aggregateParameterIndex = data["AggregateParameterIndex"];
            this.brushIndex = data["BrushIndex"];
        }
    }

    static fromJS(data: any): AggregateKey {
        data = typeof data === 'object' ? data : {};
        let result = new AggregateKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AggregateParameterIndex"] = this.aggregateParameterIndex;
        data["BrushIndex"] = this.brushIndex;
        return data;
    }
}

export interface IAggregateKey {
    aggregateParameterIndex?: number | undefined;
    brushIndex?: number | undefined;
}

export abstract class IResult implements IIResult {

    constructor(data?: IIResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): IResult {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IResult' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIResult {
}

export class DataArgument extends PrimitiveStepArgument implements IDataArgument {
    data?: string | undefined;

    constructor(data?: IDataArgument) {
        super(data);
        this._discriminator = "DataArgument";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.data = data["Data"];
        }
    }

    static fromJS(data: any): DataArgument {
        data = typeof data === 'object' ? data : {};
        let result = new DataArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        super.toJSON(data);
        return data;
    }
}

export interface IDataArgument extends IPrimitiveStepArgument {
    data?: string | undefined;
}

export class ListValue extends Value implements IListValue {
    items?: Value[] | undefined;

    constructor(data?: IListValue) {
        super(data);
        this._discriminator = "ListValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Items"] && data["Items"].constructor === Array) {
                this.items = [];
                for (let item of data["Items"])
                    this.items.push(Value.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListValue {
        data = typeof data === 'object' ? data : {};
        let result = new ListValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IListValue extends IValue {
    items?: Value[] | undefined;
}

export class Metrics implements IMetrics {
    averageAccuracy?: number | undefined;
    averageRSquared?: number | undefined;
    f1Macro?: number | undefined;

    constructor(data?: IMetrics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.averageAccuracy = data["AverageAccuracy"];
            this.averageRSquared = data["AverageRSquared"];
            this.f1Macro = data["F1Macro"];
        }
    }

    static fromJS(data: any): Metrics {
        data = typeof data === 'object' ? data : {};
        let result = new Metrics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AverageAccuracy"] = this.averageAccuracy;
        data["AverageRSquared"] = this.averageRSquared;
        data["F1Macro"] = this.f1Macro;
        return data;
    }
}

export interface IMetrics {
    averageAccuracy?: number | undefined;
    averageRSquared?: number | undefined;
    f1Macro?: number | undefined;
}

export class FeatureImportanceOperationParameters extends DistOperationParameters implements IFeatureImportanceOperationParameters {
    solutionId?: string | undefined;

    constructor(data?: IFeatureImportanceOperationParameters) {
        super(data);
        this._discriminator = "FeatureImportanceOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.solutionId = data["SolutionId"];
        }
    }

    static fromJS(data: any): FeatureImportanceOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureImportanceOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SolutionId"] = this.solutionId;
        super.toJSON(data);
        return data;
    }
}

export interface IFeatureImportanceOperationParameters extends IDistOperationParameters {
    solutionId?: string | undefined;
}

export class FeatureImportanceResult extends Result implements IFeatureImportanceResult {
    featureImportances?: { [key: string]: TupleOfDoubleAndDouble; } | undefined;

    constructor(data?: IFeatureImportanceResult) {
        super(data);
        this._discriminator = "FeatureImportanceResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["FeatureImportances"]) {
                this.featureImportances = {};
                for (let key in data["FeatureImportances"]) {
                    if (data["FeatureImportances"].hasOwnProperty(key))
                        this.featureImportances[key] = data["FeatureImportances"][key] ? TupleOfDoubleAndDouble.fromJS(data["FeatureImportances"][key]) : new TupleOfDoubleAndDouble();
                }
            }
        }
    }

    static fromJS(data: any): FeatureImportanceResult {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureImportanceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureImportances) {
            data["FeatureImportances"] = {};
            for (let key in this.featureImportances) {
                if (this.featureImportances.hasOwnProperty(key))
                    data["FeatureImportances"][key] = this.featureImportances[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFeatureImportanceResult extends IResult {
    featureImportances?: { [key: string]: TupleOfDoubleAndDouble; } | undefined;
}

export class TupleOfDoubleAndDouble implements ITupleOfDoubleAndDouble {
    item1?: number | undefined;
    item2?: number | undefined;

    constructor(data?: ITupleOfDoubleAndDouble) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.item1 = data["Item1"];
            this.item2 = data["Item2"];
        }
    }

    static fromJS(data: any): TupleOfDoubleAndDouble {
        data = typeof data === 'object' ? data : {};
        let result = new TupleOfDoubleAndDouble();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Item1"] = this.item1;
        data["Item2"] = this.item2;
        return data;
    }
}

export interface ITupleOfDoubleAndDouble {
    item1?: number | undefined;
    item2?: number | undefined;
}

export class PrimitiveStepDescription extends StepDescription implements IPrimitiveStepDescription {
    hyperparams?: { [key: string]: Value; } | undefined;

    constructor(data?: IPrimitiveStepDescription) {
        super(data);
        this._discriminator = "PrimitiveStepDescription";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Hyperparams"]) {
                this.hyperparams = {};
                for (let key in data["Hyperparams"]) {
                    if (data["Hyperparams"].hasOwnProperty(key))
                        this.hyperparams[key] = data["Hyperparams"][key] ? Value.fromJS(data["Hyperparams"][key]) : <any>undefined;
                }
            }
        }
    }

    static fromJS(data: any): PrimitiveStepDescription {
        data = typeof data === 'object' ? data : {};
        let result = new PrimitiveStepDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.hyperparams) {
            data["Hyperparams"] = {};
            for (let key in this.hyperparams) {
                if (this.hyperparams.hasOwnProperty(key))
                    data["Hyperparams"][key] = this.hyperparams[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPrimitiveStepDescription extends IStepDescription {
    hyperparams?: { [key: string]: Value; } | undefined;
}

export enum ValueType {
    VALUE_TYPE_UNDEFINED = 0,
    RAW = 1,
    DATASET_URI = 2,
    CSV_URI = 3,
    PICKLE_URI = 4,
    PICKLE_BLOB = 5,
    PLASMA_ID = 6,
}

export class DatamartSearchParameters implements IDatamartSearchParameters {
    adapterName?: string | undefined;
    queryJson?: string | undefined;

    constructor(data?: IDatamartSearchParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adapterName = data["AdapterName"];
            this.queryJson = data["QueryJson"];
        }
    }

    static fromJS(data: any): DatamartSearchParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DatamartSearchParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AdapterName"] = this.adapterName;
        data["QueryJson"] = this.queryJson;
        return data;
    }
}

export interface IDatamartSearchParameters {
    adapterName?: string | undefined;
    queryJson?: string | undefined;
}

export class DatamartAugmentParameters implements IDatamartAugmentParameters {
    adapterName?: string | undefined;
    augmentationJson?: string | undefined;
    numberOfSamples?: number | undefined;
    augmentedAdapterName?: string | undefined;

    constructor(data?: IDatamartAugmentParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adapterName = data["AdapterName"];
            this.augmentationJson = data["AugmentationJson"];
            this.numberOfSamples = data["NumberOfSamples"];
            this.augmentedAdapterName = data["AugmentedAdapterName"];
        }
    }

    static fromJS(data: any): DatamartAugmentParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DatamartAugmentParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AdapterName"] = this.adapterName;
        data["AugmentationJson"] = this.augmentationJson;
        data["NumberOfSamples"] = this.numberOfSamples;
        data["AugmentedAdapterName"] = this.augmentedAdapterName;
        return data;
    }
}

export interface IDatamartAugmentParameters {
    adapterName?: string | undefined;
    augmentationJson?: string | undefined;
    numberOfSamples?: number | undefined;
    augmentedAdapterName?: string | undefined;
}

export class RawDataResult extends DistResult implements IRawDataResult {
    samples?: { [key: string]: any[]; } | undefined;
    weightedWords?: { [key: string]: Word[]; } | undefined;

    constructor(data?: IRawDataResult) {
        super(data);
        this._discriminator = "RawDataResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Samples"]) {
                this.samples = {};
                for (let key in data["Samples"]) {
                    if (data["Samples"].hasOwnProperty(key))
                        this.samples[key] = data["Samples"][key] !== undefined ? data["Samples"][key] : [];
                }
            }
            if (data["WeightedWords"]) {
                this.weightedWords = {};
                for (let key in data["WeightedWords"]) {
                    if (data["WeightedWords"].hasOwnProperty(key))
                        this.weightedWords[key] = data["WeightedWords"][key] ? data["WeightedWords"][key].map((i: any) => Word.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): RawDataResult {
        data = typeof data === 'object' ? data : {};
        let result = new RawDataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.samples) {
            data["Samples"] = {};
            for (let key in this.samples) {
                if (this.samples.hasOwnProperty(key))
                    data["Samples"][key] = this.samples[key];
            }
        }
        if (this.weightedWords) {
            data["WeightedWords"] = {};
            for (let key in this.weightedWords) {
                if (this.weightedWords.hasOwnProperty(key))
                    data["WeightedWords"][key] = this.weightedWords[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRawDataResult extends IDistResult {
    samples?: { [key: string]: any[]; } | undefined;
    weightedWords?: { [key: string]: Word[]; } | undefined;
}

export class Word implements IWord {
    text?: string | undefined;
    occurrences?: number | undefined;
    stem?: string | undefined;
    isWordGroup?: boolean | undefined;

    constructor(data?: IWord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.text = data["Text"];
            this.occurrences = data["Occurrences"];
            this.stem = data["Stem"];
            this.isWordGroup = data["IsWordGroup"];
        }
    }

    static fromJS(data: any): Word {
        data = typeof data === 'object' ? data : {};
        let result = new Word();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Text"] = this.text;
        data["Occurrences"] = this.occurrences;
        data["Stem"] = this.stem;
        data["IsWordGroup"] = this.isWordGroup;
        return data;
    }
}

export interface IWord {
    text?: string | undefined;
    occurrences?: number | undefined;
    stem?: string | undefined;
    isWordGroup?: boolean | undefined;
}

export class SampleOperationParameters extends DistOperationParameters implements ISampleOperationParameters {
    numSamples?: number | undefined;
    attributeParameters?: AttributeParameters[] | undefined;
    brushes?: string[] | undefined;

    constructor(data?: ISampleOperationParameters) {
        super(data);
        this._discriminator = "SampleOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.numSamples = data["NumSamples"];
            if (data["AttributeParameters"] && data["AttributeParameters"].constructor === Array) {
                this.attributeParameters = [];
                for (let item of data["AttributeParameters"])
                    this.attributeParameters.push(AttributeParameters.fromJS(item));
            }
            if (data["Brushes"] && data["Brushes"].constructor === Array) {
                this.brushes = [];
                for (let item of data["Brushes"])
                    this.brushes.push(item);
            }
        }
    }

    static fromJS(data: any): SampleOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new SampleOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["NumSamples"] = this.numSamples;
        if (this.attributeParameters && this.attributeParameters.constructor === Array) {
            data["AttributeParameters"] = [];
            for (let item of this.attributeParameters)
                data["AttributeParameters"].push(item.toJSON());
        }
        if (this.brushes && this.brushes.constructor === Array) {
            data["Brushes"] = [];
            for (let item of this.brushes)
                data["Brushes"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISampleOperationParameters extends IDistOperationParameters {
    numSamples?: number | undefined;
    attributeParameters?: AttributeParameters[] | undefined;
    brushes?: string[] | undefined;
}

export class SampleResult extends DistResult implements ISampleResult {
    samples?: { [key: string]: { [key: string]: number; }; } | undefined;
    isTruncated?: boolean | undefined;

    constructor(data?: ISampleResult) {
        super(data);
        this._discriminator = "SampleResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Samples"]) {
                this.samples = {};
                for (let key in data["Samples"]) {
                    if (data["Samples"].hasOwnProperty(key))
                        this.samples[key] = data["Samples"][key] !== undefined ? data["Samples"][key] : {};
                }
            }
            this.isTruncated = data["IsTruncated"];
        }
    }

    static fromJS(data: any): SampleResult {
        data = typeof data === 'object' ? data : {};
        let result = new SampleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.samples) {
            data["Samples"] = {};
            for (let key in this.samples) {
                if (this.samples.hasOwnProperty(key))
                    data["Samples"][key] = this.samples[key];
            }
        }
        data["IsTruncated"] = this.isTruncated;
        super.toJSON(data);
        return data;
    }
}

export interface ISampleResult extends IDistResult {
    samples?: { [key: string]: { [key: string]: number; }; } | undefined;
    isTruncated?: boolean | undefined;
}

export class ResultParameters extends UniqueJson implements IResultParameters {
    operationReference?: IOperationReference | undefined;
    stopOperation?: boolean | undefined;

    protected _discriminator: string;

    constructor(data?: IResultParameters) {
        super(data);
        this._discriminator = "ResultParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.operationReference = data["OperationReference"] ? IOperationReference.fromJS(data["OperationReference"]) : <any>undefined;
            this.stopOperation = data["StopOperation"];
        }
    }

    static fromJS(data: any): ResultParameters {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "RecommenderResultParameters") {
            let result = new RecommenderResultParameters();
            result.init(data);
            return result;
        }
        let result = new ResultParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["OperationReference"] = this.operationReference ? this.operationReference.toJSON() : <any>undefined;
        data["StopOperation"] = this.stopOperation;
        super.toJSON(data);
        return data;
    }
}

export interface IResultParameters extends IUniqueJson {
    operationReference?: IOperationReference | undefined;
    stopOperation?: boolean | undefined;
}

export class RecommenderResultParameters extends ResultParameters implements IRecommenderResultParameters {
    from?: number | undefined;
    to?: number | undefined;
    pValueSorting?: Sorting | undefined;
    effectSizeFilter?: EffectSize | undefined;

    constructor(data?: IRecommenderResultParameters) {
        super(data);
        this._discriminator = "RecommenderResultParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.from = data["From"];
            this.to = data["To"];
            this.pValueSorting = data["PValueSorting"];
            this.effectSizeFilter = data["EffectSizeFilter"];
        }
    }

    static fromJS(data: any): RecommenderResultParameters {
        data = typeof data === 'object' ? data : {};
        let result = new RecommenderResultParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["From"] = this.from;
        data["To"] = this.to;
        data["PValueSorting"] = this.pValueSorting;
        data["EffectSizeFilter"] = this.effectSizeFilter;
        super.toJSON(data);
        return data;
    }
}

export interface IRecommenderResultParameters extends IResultParameters {
    from?: number | undefined;
    to?: number | undefined;
    pValueSorting?: Sorting | undefined;
    effectSizeFilter?: EffectSize | undefined;
}

export enum Sorting {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class AddComparisonParameters extends ModelOperationParameters implements IAddComparisonParameters {
    modelId?: ModelId | undefined;
    comparisonOrder?: number | undefined;
    childOperationParameters?: OperationParameters[] | undefined;
    isCachable?: boolean | undefined;

    constructor(data?: IAddComparisonParameters) {
        super(data);
        this._discriminator = "AddComparisonParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.modelId = data["ModelId"] ? ModelId.fromJS(data["ModelId"]) : <any>undefined;
            this.comparisonOrder = data["ComparisonOrder"];
            if (data["ChildOperationParameters"] && data["ChildOperationParameters"].constructor === Array) {
                this.childOperationParameters = [];
                for (let item of data["ChildOperationParameters"])
                    this.childOperationParameters.push(OperationParameters.fromJS(item));
            }
            this.isCachable = data["IsCachable"];
        }
    }

    static fromJS(data: any): AddComparisonParameters {
        data = typeof data === 'object' ? data : {};
        let result = new AddComparisonParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ModelId"] = this.modelId ? this.modelId.toJSON() : <any>undefined;
        data["ComparisonOrder"] = this.comparisonOrder;
        if (this.childOperationParameters && this.childOperationParameters.constructor === Array) {
            data["ChildOperationParameters"] = [];
            for (let item of this.childOperationParameters)
                data["ChildOperationParameters"].push(item.toJSON());
        }
        data["IsCachable"] = this.isCachable;
        super.toJSON(data);
        return data;
    }
}

export interface IAddComparisonParameters extends IModelOperationParameters {
    modelId?: ModelId | undefined;
    comparisonOrder?: number | undefined;
    childOperationParameters?: OperationParameters[] | undefined;
    isCachable?: boolean | undefined;
}

export class CDFResult extends DistResult implements ICDFResult {
    cDF?: { [key: string]: number; } | undefined;

    constructor(data?: ICDFResult) {
        super(data);
        this._discriminator = "CDFResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["CDF"]) {
                this.cDF = {};
                for (let key in data["CDF"]) {
                    if (data["CDF"].hasOwnProperty(key))
                        this.cDF[key] = data["CDF"][key];
                }
            }
        }
    }

    static fromJS(data: any): CDFResult {
        data = typeof data === 'object' ? data : {};
        let result = new CDFResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cDF) {
            data["CDF"] = {};
            for (let key in this.cDF) {
                if (this.cDF.hasOwnProperty(key))
                    data["CDF"][key] = this.cDF[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICDFResult extends IDistResult {
    cDF?: { [key: string]: number; } | undefined;
}

export class ChiSquaredTestResult extends HypothesisTestResult implements IChiSquaredTestResult {
    hs_aligned?: TupleOfDoubleAndDouble[] | undefined;

    constructor(data?: IChiSquaredTestResult) {
        super(data);
        this._discriminator = "ChiSquaredTestResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["hs_aligned"] && data["hs_aligned"].constructor === Array) {
                this.hs_aligned = [];
                for (let item of data["hs_aligned"])
                    this.hs_aligned.push(TupleOfDoubleAndDouble.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChiSquaredTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new ChiSquaredTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.hs_aligned && this.hs_aligned.constructor === Array) {
            data["hs_aligned"] = [];
            for (let item of this.hs_aligned)
                data["hs_aligned"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IChiSquaredTestResult extends IHypothesisTestResult {
    hs_aligned?: TupleOfDoubleAndDouble[] | undefined;
}

export class CorrelationTestResult extends HypothesisTestResult implements ICorrelationTestResult {
    degreeOfFreedom?: number | undefined;
    sampleCorrelationCoefficient?: number | undefined;
    distResult?: EmpiricalDistResult | undefined;

    constructor(data?: ICorrelationTestResult) {
        super(data);
        this._discriminator = "CorrelationTestResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.degreeOfFreedom = data["DegreeOfFreedom"];
            this.sampleCorrelationCoefficient = data["SampleCorrelationCoefficient"];
            this.distResult = data["DistResult"] ? EmpiricalDistResult.fromJS(data["DistResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CorrelationTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new CorrelationTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DegreeOfFreedom"] = this.degreeOfFreedom;
        data["SampleCorrelationCoefficient"] = this.sampleCorrelationCoefficient;
        data["DistResult"] = this.distResult ? this.distResult.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICorrelationTestResult extends IHypothesisTestResult {
    degreeOfFreedom?: number | undefined;
    sampleCorrelationCoefficient?: number | undefined;
    distResult?: EmpiricalDistResult | undefined;
}

export class EmpiricalDistResult extends DistResult implements IEmpiricalDistResult {
    marginals?: AttributeParameters[] | undefined;
    marginalDistParameters?: { [key: string]: DistParameter; } | undefined;
    jointDistParameter?: JointDistParameter | undefined;

    constructor(data?: IEmpiricalDistResult) {
        super(data);
        this._discriminator = "EmpiricalDistResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["Marginals"] && data["Marginals"].constructor === Array) {
                this.marginals = [];
                for (let item of data["Marginals"])
                    this.marginals.push(AttributeParameters.fromJS(item));
            }
            if (data["MarginalDistParameters"]) {
                this.marginalDistParameters = {};
                for (let key in data["MarginalDistParameters"]) {
                    if (data["MarginalDistParameters"].hasOwnProperty(key))
                        this.marginalDistParameters[key] = data["MarginalDistParameters"][key] ? DistParameter.fromJS(data["MarginalDistParameters"][key]) : new DistParameter();
                }
            }
            this.jointDistParameter = data["JointDistParameter"] ? JointDistParameter.fromJS(data["JointDistParameter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmpiricalDistResult {
        data = typeof data === 'object' ? data : {};
        let result = new EmpiricalDistResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.marginals && this.marginals.constructor === Array) {
            data["Marginals"] = [];
            for (let item of this.marginals)
                data["Marginals"].push(item.toJSON());
        }
        if (this.marginalDistParameters) {
            data["MarginalDistParameters"] = {};
            for (let key in this.marginalDistParameters) {
                if (this.marginalDistParameters.hasOwnProperty(key))
                    data["MarginalDistParameters"][key] = this.marginalDistParameters[key];
            }
        }
        data["JointDistParameter"] = this.jointDistParameter ? this.jointDistParameter.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IEmpiricalDistResult extends IDistResult {
    marginals?: AttributeParameters[] | undefined;
    marginalDistParameters?: { [key: string]: DistParameter; } | undefined;
    jointDistParameter?: JointDistParameter | undefined;
}

export class DistParameter implements IDistParameter {
    mean?: number | undefined;
    moment2?: number | undefined;
    variance?: number | undefined;
    varianceEstimate?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;

    constructor(data?: IDistParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mean = data["Mean"];
            this.moment2 = data["Moment2"];
            this.variance = data["Variance"];
            this.varianceEstimate = data["VarianceEstimate"];
            this.min = data["Min"];
            this.max = data["Max"];
        }
    }

    static fromJS(data: any): DistParameter {
        data = typeof data === 'object' ? data : {};
        let result = new DistParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Mean"] = this.mean;
        data["Moment2"] = this.moment2;
        data["Variance"] = this.variance;
        data["VarianceEstimate"] = this.varianceEstimate;
        data["Min"] = this.min;
        data["Max"] = this.max;
        return data;
    }
}

export interface IDistParameter {
    mean?: number | undefined;
    moment2?: number | undefined;
    variance?: number | undefined;
    varianceEstimate?: number | undefined;
    min?: number | undefined;
    max?: number | undefined;
}

export class JointDistParameter implements IJointDistParameter {
    jointDist?: DistParameter | undefined;
    covariance?: number | undefined;

    constructor(data?: IJointDistParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jointDist = data["JointDist"] ? DistParameter.fromJS(data["JointDist"]) : <any>undefined;
            this.covariance = data["Covariance"];
        }
    }

    static fromJS(data: any): JointDistParameter {
        data = typeof data === 'object' ? data : {};
        let result = new JointDistParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["JointDist"] = this.jointDist ? this.jointDist.toJSON() : <any>undefined;
        data["Covariance"] = this.covariance;
        return data;
    }
}

export interface IJointDistParameter {
    jointDist?: DistParameter | undefined;
    covariance?: number | undefined;
}

export enum DistributionType {
    Continuous = 0,
    Discrete = 1,
}

export abstract class DistributionTypeExtension implements IDistributionTypeExtension {

    constructor(data?: IDistributionTypeExtension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): DistributionTypeExtension {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DistributionTypeExtension' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IDistributionTypeExtension {
}

export class GetModelStateParameters extends ModelOperationParameters implements IGetModelStateParameters {
    modelId?: ModelId | undefined;
    comparisonIds?: ComparisonId[] | undefined;
    riskControlType?: RiskControlType | undefined;

    constructor(data?: IGetModelStateParameters) {
        super(data);
        this._discriminator = "GetModelStateParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.modelId = data["ModelId"] ? ModelId.fromJS(data["ModelId"]) : <any>undefined;
            if (data["ComparisonIds"] && data["ComparisonIds"].constructor === Array) {
                this.comparisonIds = [];
                for (let item of data["ComparisonIds"])
                    this.comparisonIds.push(ComparisonId.fromJS(item));
            }
            this.riskControlType = data["RiskControlType"];
        }
    }

    static fromJS(data: any): GetModelStateParameters {
        data = typeof data === 'object' ? data : {};
        let result = new GetModelStateParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ModelId"] = this.modelId ? this.modelId.toJSON() : <any>undefined;
        if (this.comparisonIds && this.comparisonIds.constructor === Array) {
            data["ComparisonIds"] = [];
            for (let item of this.comparisonIds)
                data["ComparisonIds"].push(item.toJSON());
        }
        data["RiskControlType"] = this.riskControlType;
        super.toJSON(data);
        return data;
    }
}

export interface IGetModelStateParameters extends IModelOperationParameters {
    modelId?: ModelId | undefined;
    comparisonIds?: ComparisonId[] | undefined;
    riskControlType?: RiskControlType | undefined;
}

export class KSTestResult extends HypothesisTestResult implements IKSTestResult {

    constructor(data?: IKSTestResult) {
        super(data);
        this._discriminator = "KSTestResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
        }
    }

    static fromJS(data: any): KSTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new KSTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IKSTestResult extends IHypothesisTestResult {
}

export class ModelWealthParameters extends UniqueJson implements IModelWealthParameters {
    modelId?: ModelId | undefined;
    riskControlType?: RiskControlType | undefined;

    constructor(data?: IModelWealthParameters) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.modelId = data["ModelId"] ? ModelId.fromJS(data["ModelId"]) : <any>undefined;
            this.riskControlType = data["RiskControlType"];
        }
    }

    static fromJS(data: any): ModelWealthParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ModelWealthParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ModelId"] = this.modelId ? this.modelId.toJSON() : <any>undefined;
        data["RiskControlType"] = this.riskControlType;
        super.toJSON(data);
        return data;
    }
}

export interface IModelWealthParameters extends IUniqueJson {
    modelId?: ModelId | undefined;
    riskControlType?: RiskControlType | undefined;
}

export class RootMeanSquareTestResult extends HypothesisTestResult implements IRootMeanSquareTestResult {
    simulationCount?: number | undefined;
    extremeSimulationCount?: number | undefined;

    constructor(data?: IRootMeanSquareTestResult) {
        super(data);
        this._discriminator = "RootMeanSquareTestResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.simulationCount = data["SimulationCount"];
            this.extremeSimulationCount = data["ExtremeSimulationCount"];
        }
    }

    static fromJS(data: any): RootMeanSquareTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new RootMeanSquareTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SimulationCount"] = this.simulationCount;
        data["ExtremeSimulationCount"] = this.extremeSimulationCount;
        super.toJSON(data);
        return data;
    }
}

export interface IRootMeanSquareTestResult extends IHypothesisTestResult {
    simulationCount?: number | undefined;
    extremeSimulationCount?: number | undefined;
}

export class TTestResult extends HypothesisTestResult implements ITTestResult {
    degreeOfFreedom?: number | undefined;
    distResults?: EmpiricalDistResult[] | undefined;

    constructor(data?: ITTestResult) {
        super(data);
        this._discriminator = "TTestResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.degreeOfFreedom = data["DegreeOfFreedom"];
            if (data["DistResults"] && data["DistResults"].constructor === Array) {
                this.distResults = [];
                for (let item of data["DistResults"])
                    this.distResults.push(EmpiricalDistResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new TTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DegreeOfFreedom"] = this.degreeOfFreedom;
        if (this.distResults && this.distResults.constructor === Array) {
            data["DistResults"] = [];
            for (let item of this.distResults)
                data["DistResults"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITTestResult extends IHypothesisTestResult {
    degreeOfFreedom?: number | undefined;
    distResults?: EmpiricalDistResult[] | undefined;
}

export enum Sorting2 {
    Ascending = 0,
    Descending = 1,
}

export class BinLabel implements IBinLabel {
    value?: number | undefined;
    minValue?: number | undefined;
    maxValue?: number | undefined;
    label?: string | undefined;

    constructor(data?: IBinLabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["Value"];
            this.minValue = data["MinValue"];
            this.maxValue = data["MaxValue"];
            this.label = data["Label"];
        }
    }

    static fromJS(data: any): BinLabel {
        data = typeof data === 'object' ? data : {};
        let result = new BinLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        data["MinValue"] = this.minValue;
        data["MaxValue"] = this.maxValue;
        data["Label"] = this.label;
        return data;
    }
}

export interface IBinLabel {
    value?: number | undefined;
    minValue?: number | undefined;
    maxValue?: number | undefined;
    label?: string | undefined;
}

export class PreProcessedString implements IPreProcessedString {
    value?: string | undefined;
    id?: number | undefined;
    stringLookup?: { [key: string]: number; } | undefined;
    indexLookup?: { [key: string]: string; } | undefined;

    constructor(data?: IPreProcessedString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["Value"];
            this.id = data["Id"];
            if (data["StringLookup"]) {
                this.stringLookup = {};
                for (let key in data["StringLookup"]) {
                    if (data["StringLookup"].hasOwnProperty(key))
                        this.stringLookup[key] = data["StringLookup"][key];
                }
            }
            if (data["IndexLookup"]) {
                this.indexLookup = {};
                for (let key in data["IndexLookup"]) {
                    if (data["IndexLookup"].hasOwnProperty(key))
                        this.indexLookup[key] = data["IndexLookup"][key];
                }
            }
        }
    }

    static fromJS(data: any): PreProcessedString {
        data = typeof data === 'object' ? data : {};
        let result = new PreProcessedString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        data["Id"] = this.id;
        if (this.stringLookup) {
            data["StringLookup"] = {};
            for (let key in this.stringLookup) {
                if (this.stringLookup.hasOwnProperty(key))
                    data["StringLookup"][key] = this.stringLookup[key];
            }
        }
        if (this.indexLookup) {
            data["IndexLookup"] = {};
            for (let key in this.indexLookup) {
                if (this.indexLookup.hasOwnProperty(key))
                    data["IndexLookup"][key] = this.indexLookup[key];
            }
        }
        return data;
    }
}

export interface IPreProcessedString {
    value?: string | undefined;
    id?: number | undefined;
    stringLookup?: { [key: string]: number; } | undefined;
    indexLookup?: { [key: string]: string; } | undefined;
}

export class BitSet implements IBitSet {
    length?: number | undefined;
    size?: number | undefined;

    constructor(data?: IBitSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.length = data["Length"];
            this.size = data["Size"];
        }
    }

    static fromJS(data: any): BitSet {
        data = typeof data === 'object' ? data : {};
        let result = new BitSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Length"] = this.length;
        data["Size"] = this.size;
        return data;
    }
}

export interface IBitSet {
    length?: number | undefined;
    size?: number | undefined;
}

export class DateTimeUtil implements IDateTimeUtil {

    constructor(data?: IDateTimeUtil) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): DateTimeUtil {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeUtil();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IDateTimeUtil {
}

export class FrequentItemsetOperationParameters extends DistOperationParameters implements IFrequentItemsetOperationParameters {
    filter?: string | undefined;
    attributeParameters?: AttributeParameters[] | undefined;
    attributeCodeParameters?: AttributeCaclculatedParameters[] | undefined;

    constructor(data?: IFrequentItemsetOperationParameters) {
        super(data);
        this._discriminator = "FrequentItemsetOperationParameters";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.filter = data["Filter"];
            if (data["AttributeParameters"] && data["AttributeParameters"].constructor === Array) {
                this.attributeParameters = [];
                for (let item of data["AttributeParameters"])
                    this.attributeParameters.push(AttributeParameters.fromJS(item));
            }
            if (data["AttributeCodeParameters"] && data["AttributeCodeParameters"].constructor === Array) {
                this.attributeCodeParameters = [];
                for (let item of data["AttributeCodeParameters"])
                    this.attributeCodeParameters.push(AttributeCaclculatedParameters.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FrequentItemsetOperationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new FrequentItemsetOperationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter;
        if (this.attributeParameters && this.attributeParameters.constructor === Array) {
            data["AttributeParameters"] = [];
            for (let item of this.attributeParameters)
                data["AttributeParameters"].push(item.toJSON());
        }
        if (this.attributeCodeParameters && this.attributeCodeParameters.constructor === Array) {
            data["AttributeCodeParameters"] = [];
            for (let item of this.attributeCodeParameters)
                data["AttributeCodeParameters"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFrequentItemsetOperationParameters extends IDistOperationParameters {
    filter?: string | undefined;
    attributeParameters?: AttributeParameters[] | undefined;
    attributeCodeParameters?: AttributeCaclculatedParameters[] | undefined;
}

export class FrequentItemsetResult extends Result implements IFrequentItemsetResult {
    frequentItems?: { [key: string]: number; } | undefined;

    constructor(data?: IFrequentItemsetResult) {
        super(data);
        this._discriminator = "FrequentItemsetResult";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["FrequentItems"]) {
                this.frequentItems = {};
                for (let key in data["FrequentItems"]) {
                    if (data["FrequentItems"].hasOwnProperty(key))
                        this.frequentItems[key] = data["FrequentItems"][key];
                }
            }
        }
    }

    static fromJS(data: any): FrequentItemsetResult {
        data = typeof data === 'object' ? data : {};
        let result = new FrequentItemsetResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.frequentItems) {
            data["FrequentItems"] = {};
            for (let key in this.frequentItems) {
                if (this.frequentItems.hasOwnProperty(key))
                    data["FrequentItems"][key] = this.frequentItems[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFrequentItemsetResult extends IResult {
    frequentItems?: { [key: string]: number; } | undefined;
}

